<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Introduction - Simple Kombinator Interpreter</title>
    <link rel="shortcut icon" type="image/png" href="img/ski-64.png">
    <script src="build/js/ski-interpreter.min.js"></script>
    <script src="js/util-html.js"></script>
    <script src="js/util-ski.js"></script>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
<h1><img src="img/mock1.png">Simple Kombinator Interpreter Intro<img src="img/mock2.png"></h1>

<div id="intro" style="padding: 1ex;">
    <div class="chapter">
        <h2>Preamble</h2>
        <p>Welcome to the wonderful world of combinatory logic,
            a lovechild of lisp and brainfuck, developed by 
            <a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">Moses Schönfinkel</a> and 
            <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a> in the 1920s to study the underpinnings of logic.</p>
        
        <p>In modern terms, combinatory logic is a variable-free programming language that works as simple it possibly gets.
            A combinator is a one-argument function that accepts a one-argument function and
            returns a one-argument function.
            Everything here is a function - numbers, booleans, lists, and even free variables
            stand for functions we don't know how to compute just yet.</p>
    </div>

    <div class="chapter">
        <h2>How is works</h2>

        <ul>
            <li>Given that <code>x</code> and <code>y</code> are combinators, then so is <code>x y</code>, namely the one
                returned by <code>x</code> when applied to <code>y</code>.</li>
            <li>If <code>z</code> is also a combinator, so is
                <code>(x y) z</code>, also written <code>x y z</code> to save on parentheses. Beware that <code>x (y z)</code> is <i>not</i> the same as <code>(x y) z</code>
                (at least not for arbitrary terms).</li>
            <li>We'll use capital letters for common combinators and allow lumping them together to save on space: <code>CBx</code> = <code>C B x</code>.
                Lowercase identifiers must be separated: <code>f1 arg</code>, or <code>f1(arg)</code> or <code>(f1)arg</code>.</li>
            <li>
                If a <i>reduction rule</i> is known for the <i>leftmost</i> term in an (sub-)expression, it is applied.
                Reduction rules are given in the form of <code>X a b c = b (c a)</code>
                and are interpreted as follows:
                <code>X a</code> returns a function <code>f1</code> such that
                <code>f1 b</code> returns a function <code>f2</code> such that
                <code>f2 c</code> returns expression <code>b (c a)</code>.
                This technique is known as currying.
            </li>

            <li>
                A computation terminates when no more reductions can be made.
            </li>
        </ul>

        <p>With a right inventory of initial combinators this is enough for Turing completeness.</p>
    </div>
    <div class="chapter">
        <h2>The S, K, I basis</h2>

        <p>The <a href="https://en.wikipedia.org/wiki/To_Mock_a_Mockingbird">tradition</a> is to depict the combinators as birds, 
            and we won't be stepping too far away from it.</p>
        <p>
            <code>I</code>, the Ibis, or Identity<sup>1</sup>, has a very simple reduction rule:
            for any term <code>x</code>, <code>I x = x</code>.
            Thus <code>IIx</code>, <code>I(II)x</code>, <code>II(Ix)</code> and so on all converge to <code>x</code>.
            Note, however, that <code>x I</code> does not equal <code>x</code>
            and <code>x I y</code> does not equal <code>x y</code>.</p>

        <p>
            <code>K</code>, the Kestrel, or Konstant, is defined as <code>K x y = x</code>.
            Here's where currying happens for real:
            K x returns a function which in turn discards its argument and returns x and nothing else.
            Note again that <code>x K y z</code> does not become <code>x y</code> because <code>K</code>
            is not in the first place and the reduction rule is not applicable.
        </p>

        <p>
            <code>S</code>, the Starling, adheres <code>S f g x = f x (g x)</code>.
            That is, given two functions and an argument (which is also a function given the setup,
            but it's not important here), it applies both functions to the argument and fuses the results together.
        </p>

        
        <p>
            We encourage you to explore the combinators yourself:
        </p>
        
        <ul class="menu">
            <li><a href="index.html">Play with Simple Kombinator Interpreter</a> to get some feel</li>
            <li><a href="quest.html">Solve some quests</a> to learn how to represent and manipulate data</li>
        </ul>
    </div>
    
    <div class="chapter">
        <h2>Connection to λ-calculus</h2>
                
        <p>An arbitrary λ-expression can be converted to SKI via the following rules:</p>
        <ul>
            <li><code>x &mapsto; x</code> becomes <code>I</code>;</li>
            <li><code>x &mapsto; y</code> (where y contains no x) becomes <code>K y</code>;</li>
            <li><code>x &mapsto; y(x)</code> (where y contains no x) becomes <code>y</code>;</li>
            <li><code>x &mapsto; y(z)</code> becomes <code>S(x &mapsto; y)(x &mapsto; z)</code>,
                where <code>y</code> and <code>z</code> may or may not depend on <code>x</code>.
            </li>
            <li>The process, known as bracket abstraction, is repeated from the innermost λ-expression
                outwards and is guaranteed to terminate.</li>
        </ul>
        <p>For an optimal conversion algorithm, see
        <a href="https://okmij.org/ftp/tagless-final/ski.pdf">λ to SKI, Semantically</a>
        by Oleg Kiselyov (Tohoku University, Japan) and
        <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">detailed implementation notes</a> by Ben Lynn.</p>
    </div>

    <div class="chapter">
        <h2>Minimal basis</h2>
        <p><code>X</code>, the combinator adhering <code>X x = x(X(X(X(XX))))(X(X(XX)))</code>, is sufficient to reconstruct
        <code>I = XX</code>, <code>K = X(XI)</code>, and <code>S = XK</code>.</p>
        
        <p>This way, combinatory logic with a sole <code>X</code> combinator already interprets λ-calculus and is Turing-complete<sup>2</sup>.
        We have obtained a <a href="https://en.wikipedia.org/wiki/Iota_and_Jot">programming language</a> whose expressions are formed
        from a single combinator by applicatation and can be seen as finite binary trees:</p>
        <table align="center">
            <tr><td align="center">&nbsp; ((XX)X)X</td>
                <td align="center">(X(XX))X</td>
                <td align="center">(XX)(XX) &nbsp;</td>
                <td align="center">X((XX)X) &nbsp; &nbsp;</td>
                <td align="center">X(X(XX)) &nbsp; &nbsp; &nbsp;</td>
            </tr>
            <tr><td colspan="5"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Catalan_4_leaves_binary_tree_example.svg/600px-Catalan_4_leaves_binary_tree_example.svg.png"></td></tr>
        </table>
        <p>Computational behavior of this programming language is completely captured by identifying each expression with
        the expressions that arise when the reduction rule for <code>X</code> is applied. For the mathematicians among us,
        we just said that combinatory logic can be described as the free magma<sup>3</sup> (set with a binary operation) generated by a
        single constant <code>X</code> and a single identity, the reduction rule of <code>X</code>. This way, combinatory
        logic admits an extremely concise description featuring an exceptionally straightforward and simple computation mechanism.</p>
    </div>
    
    <div class="chapter">
        <h2>Connection to logic</h2>
        <p>Meet Euclid's theorem: for every number <i>n</i> there is a prime <i>p > n</i>.<br/>
            For millennia, mathematicians used to state mathematical facts like this using everyday languages,
            until they were superseded by a formalized language called predicate logic.<br/>
            There, Euclid's theorem reads <code>∀(n) ∃(p, p > n) p prime</code>.</p>

        <p>Symbols like ∀ (for all) and ∃ (exists) are called quantifiers and they introduce lexically scoped variables,
            <i>n</i> and <i>p</i> in case of Euclid's theorem as we stated it. Lexical variables are somewhat nontrivial
            to deal with, while mathematicians strived for completely straightforward minimalistic foundation, a “trusted core”.
            So they seeked for an alternative, variable-free notation for predicate logic, which was the original motivation
            for developing combinatory logic.</p>

        <p>Not only predicate logic, but in fact any language with scoped variables can be embedded into the variable-free
            language of combinatory logic, which turned out to be extremely minimalistic and straightforward, as desired for
            a “trusted core formalism”, but its Turing completeness makes it impossible to single out expressions coming from
            the language being embedded, unless a typing discipline is introduced.</p>
        
        <p>Eventually, <a href="https://en.wikipedia.org/wiki/Willard_Van_Orman_Quine">W. V. Quine</a>
            (<a href="https://www.jstor.org/stable/985250">Variables explained away</a>, 1960) devised a typed combinatory
            logic flavour called <a href="https://en.wikipedia.org/wiki/Predicate_functor_logic">Predicate Functor Logic</a>
            providing a variable-free notation for predicate logic. Such variable-free representations of languages featuring
            untyped or simply typed variables are now well-understood, while languages featuring dependently typed variables
            remain a vibrant research area.
        </p>
     </div>

    <div class="notes" style="margin-top: 2em">
     <hr/>
     <p><small>1. As a matter of fact, <code>I</code> can be derived from <code>S</code> and <code>K</code>, so they already form
         a basis.<br/>
         2. There is an infinite number of combinators like <code>X</code> that form a single-combinator basis, but
         they are neccesarily improper, i.e. they cannot have reduction rules that only contain free variables on the right
         hand side like it is the case for <code>S</code>, <code>K</code>, and <code>I</code>.<br/>
        3. One could argue that finite bit strings are simpler than binary trees. And indeed, there is a Turing-complete
        comutational system that can be described as a free semigroup (set with an associative binary operation) generated
        by two constants (hence, its expressions are finite bit strings) and several hundreed identities. It is generaly
        assumed that the number of required identities can be greatly reduced. Recently, Halava, Matiyasevich, and Niskanen
        <a href="https://journals.sagepub.com/doi/10.3233/FI-2017-1559">devised universal semigroup</a> presented by 24 short
        identities, at cost of extending the alphabet to 8 constants instead of two. It is known that the number of identities
        can be reduced to three at cost of yet larger alphabet and much greater identity complexity. Existence of universal semigroups
        with one or two identities remains an open problem since 1914.</small></p>
    </div>
</div>
</body>
</html>
