<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Introduction - Simple Kombinator Interpreter</title>
    <link rel="shortcut icon" type="image/png" href="img/ski-64.png">
    <script src="build/js/ski-interpreter.js"></script>
    <script src="js/util-html.js"></script>
    <script src="js/util-ski.js"></script>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
<h1><img src="img/mock1.png">Simple Kombinator Interpreter Intro<img src="img/mock2.png"></h1>

<div id="intro" style="padding: 1ex;">
    <div class="chapter">
        <h2>Preamble</h2>
        <p>Welcome to the wonderful world of combinatory logic,
            a lovechild of lisp and brainfuck, developed by 
            <a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">Moses Schönfinkel</a> and 
            <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a> in the 1920s to study the underpinnings of logic.</p>
        
        <p>In modern terms, combinatory logic is a variable-free programming language that works as simple it possibly gets.
            A combinator is a one-argument function that accepts a one-argument function and
            returns a one-argument function.
            Everything here is a function - numbers, booleans, lists, and even free variables
            stand for functions we don't know how to compute just yet.</p>
        <p>The <a href="https://en.wikipedia.org/wiki/To_Mock_a_Mockingbird">tradition</a> is to depict the combinators as birds, 
            and we won't be stepping too far away from it.</p>
    </div>

    <div class="chapter">
        <h2>How is works</h2>

        <ul>
            <li>Given that <code>x</code> and <code>y</code> are combinators, then so is <code>x y</code>, namely the one
                returned by <code>x</code> when applied to <code>y</code>.</li>
            <li>If <code>z</code> is also a combinator, so is
                <code>(x y) z</code>, also written <code>x y z</code> to save on parentheses. Beware that <code>x (y z)</code> is <i>not</i> the same as <code>(x y) z</code>
                (at least not for arbitrary terms).</li>
            <li>We'll use capital letters for common combinators and allow lumping them together to save on space: <code>CBx</code> = <code>C B x</code>.
                Lowercase identifiers must be separated: <code>f1 arg</code>, or <code>f1(arg)</code> or <code>(f1)arg</code>.</li>
            <li>
                If a <i>reduction rule</i> is known for the <i>leftmost</i> term in an (sub-)expression, it is applied.
                Reduction rules are given in the form of <code>X a b c = b (c a)</code>
                and are interpreted as follows:
                <code>X a</code> returns a function <code>f1</code> such that
                <code>f1 b</code> returns a function <code>f2</code> such that
                <code>f2 c</code> returns expression <code>b (c a)</code>.
                This technique is known as currying.
            </li>

            <li>
                A computation terminates when no more reductions can be made.
            </li>
        </ul>

        <p>With a right inventory of initial combinators this is enough for Turing completeness (computational universality).</p>
    </div>
    <div class="chapter">
        <h2>The {S, K, I} basis and λ-calculus</h2>

        <p>
            <code>I</code>, the Ibis, or Identity, has a very simple reduction rule:
            for any term <code>x</code>, <code>I x = x</code>.
            Thus <code>IIx</code>, <code>I(II)x</code>, <code>II(Ix)</code> and so on all converge to <code>x</code>.
            Note, however, that <code>x I</code> does not equal <code>x</code>
            and <code>x I y</code> does not equal <code>x y</code>.</p>

        <p>
            K, the Kestrel, or Konstant, is defined as <code>K x y = x</code>.
            Here's where currying happens for real:
            K x returns a function which in turn discards its argument and returns x and nothing else.
            Note again that <code>x K y z</code> does not become <code>x y</code> because <code>K</code>
            is not in the first place and the reduction rule is not applicable.
        </p>

        <p>
            <code>S</code>, the Starling, adheres <code>S f g x = f x (g x)</code>.
            That is, given two functions and an argument (which is also a function given the setup,
            but it's not important here), it applies both functions to the argument and fuses the results together.
        </p>
                
        <p>An arbitrary λ-expression can be converted to SKI via the following rules:</p>
        <ul>
            <li><code>x &mapsto; x</code> becomes <code>I</code>;</li>
            <li><code>x &mapsto; y</code> (where y contains no x) becomes <code>K y</code>;</li>
            <li><code>x &mapsto; y(x)</code> (where y contains no x) becomes <code>y</code>;</li>
            <li><code>x &mapsto; y(z)</code> becomes <code>S(x &mapsto; y)(x &mapsto; z)</code>,
                where <code>y</code> and <code>z</code> may or may not depend on <code>x</code>.
            </li>
            <li>The process, known as bracket abstraction, is repeated from the innermost λ-expression
                outwards and is guaranteed to terminate.</li>
        </ul>
        <p>For an optimal conversion algorithm, see
        <a href="https://okmij.org/ftp/tagless-final/ski.pdf">λ to SKI, Semantically — Declarative Pearl</a>
        by Oleg Kiselyov (Tohoku University, Japan) and
        <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">detailed implementation notes</a> by Ben Lynn.</p>

        <p><code>X</code>, the combinator adhering <code>X x = x(X(X(X(XX))))(X(X(XX)))</code>, is sufficient to reconstruct
        <code>I = XX</code>, <code>K = X(XI)</code>, and <code>S = XK</code>. This way, combinatory logic with a sole
        <code>X</code> combinator already interprets λ-calculus and is Turing-complete. Combinatory logic can thus be defined
        as an equational theory with a single binary operation (application), a single constant (<code>X</code>) and a single
        identity (the reduction rule stated above), which might be the simplest thinkable computationally universal system.
    </div>
    
    <div class="chapter">
        <h2>What's connection to logic?</h2>
        <p>Meet Euclid's theorem: <b>for every number <i>n</i> there is a prime <i>p > n</i></b>.
            For millennia, mathematicians used to state mathematical facts like this using everyday languages,
            until they were superseded by a formalized language called predicate logic,
            where Euclid's theorem looks like this: <code>∀(n) ∃(p, p > n) p prime</code>.</p>

        <p>Symbols like ∀ (for all) and ∃ (exists) are called quantifiers and they introduce lexically scoped variables,
            <i>n</i> and <i>p</i> in case of Euclid's theorem as we stated it. Lexical variables are somewhat nontrivial
            to deal with, while mathematicians strived for completely straightforward minimalistic foundation, a “trusted core”.
            So they seeked for an alternative, variable-free notation for predicate logic, which was the original motivation
            for developing combinatory logic.</p>

        <p>Not only predicate logic, but in fact any language with scoped variables can be embedded into the variable-free
            language of combinatory logic, which turned out to be extremely minimalistic and straightforward, as desired for
            a “trusted core formalism”, but its Turing completeness makes it impossible to single out expressions coming from
            the language being embedded, unless a typing discipline is introduced.</p>
        
        <p>Eventually, W. V. Quine (“Variables explained away”, 1960) has developed a typed combinatory logic flavour called
            <a href="https://en.wikipedia.org/wiki/Predicate_functor_logic">Predicate Functor Logic</a> providing
            a variable-free notation for predicate logic. Such variable-free representations of languages featuring untyped
            or simply-typed variables are now well-understood, while languages featuring dependently typed variables remain
            a remain a vibrant research area.
        </p>
     </div>

    
    <div class="chapter">
        <h2>In place of a conclusion</h2>

        What next?
        <ul class="menu">
            <li><a href="index.html">The interpreter</a></li>
            <li><a href="quest.html">Solve some quests</a></li>
            <li><a href="https://github.com/dallaylaen/ski-interpreter">Improve this document</a></li>
        </ul>
    </div>

</div>
</body>
</html>
