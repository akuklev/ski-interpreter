(()=>{var t={10:(t,n,r)=>{const e=r(592);t.exports={...e},"undefined"!=typeof window&&(window.SKI=e.SKI)},592:t=>{class n{combine(...t){return t.length>0?new r(this,...t):this}expand(){return this}reduce(t){return null}step(){return null}run(t={},...r){t instanceof n&&(r.unshift(t),t={});let e=r?this.combine(...r):this,s=t.count??0;const i=(t.max??1e3)+s;let o=!1;for(;s<i;s++){const t=e.step();if(!t){o=!0;break}e=t}return{final:o,steps:s,result:e}}isNative(){return!1}getVars(t){const n=t.split(/\s+/),r=this.freevars??{};return n.map((t=>{if(!r[t])throw new Error("Unknown free variable "+t);return r[t]}))}test(t,n,r={}){const e=t.run({max:r.max},...this.getVars(n));if(!e.final)throw new Error("Could not complete evaluation in "+r.max+" steps");return{pass:this.equals(e.result),count:e.count}}equals(t){return this===t}toString(){throw new Error("toString() undefined for generic AST")}}class r extends n{constructor(t,...n){super(),this.fun=t,this.args=n,this.final=!1}combine(...t){return 0===t.length?this:this.fun.combine(...this.args,...t)}expand(){return this.fun.expand().combine(...this.args.map((t=>t.expand())))}step(){if(this.final)return null;if(this.fun.fast){const t=this.fun.reduce(this.args);if(t)return t}const t=this.fun.step();let n=t?1:0;const r=[];for(const t of this.args){const e=t.step();r.push(e??t),e&&n++}if(n)return(t??this.fun).combine(...r);return this.fun.reduce(this.args)||(this.final=!0,null)}equals(t){if(!(t instanceof r))return!1;if(t.args.length!==this.args.length)return!1;if(!this.fun.equals(t.fun))return!1;for(let n=0;n<this.args.length;n++)if(!this.args[n].equals(t.args[n]))return!1;return!0}toString(){return this.fun.toString()+this.args.map((t=>"("+t+")")).join("")}}class e extends n{constructor(t){super(),this.name=t}toString(){return this.name}}class s extends e{constructor(t,n,r,e={}){super(t),this.arity=n,this.impl=r,e.fast&&(this.fast=!0)}reduce(t){if(t.length<this.arity)return null;const n=t.splice(this.arity);return this.impl(...t).combine(...n)}isNative(){return!0}}class i extends n{combine(...t){return t.length?t.shift().combine(...t):this}toString(){return"<empty>"}}class o extends e{constructor(t,n){super(t),this.impl=n}expand(){return this.impl.expand()}step(){return this.impl}toString(){return this.outdated?this.impl.toString():super.toString()}}t.exports={SKI:class{constructor(){this.known={},this.add("I",[1,t=>t,{fast:!0}],"x -> x"),this.add("K",[2,(t,n)=>t,{fast:!0}],"(x y) -> x"),this.add("S",[3,(t,n,r)=>t.combine(r,n.combine(r))],"(x y z) -> x z (y z)")}add(t,r,e=""){if("string"==typeof r)r=new o(t,this.parse(r));else if(Array.isArray(r))r=new s(t,r[0],r[1],r[2]??{});else{if(!(r instanceof n))throw new Error("add: impl must be an Ast, a string, or a [arity, impl] pair");r=new o(t,r)}return r.note=e,this.known[t]=r,this}remove(t){return this.known[t].outdated=!0,delete this.known[t],this}getTerms(){return{...this.known}}parse(t){const n=[...t.matchAll(/([()A-Z]|[a-z_][a-z_0-9]*)|\s+|($)/gys)],r=n.pop();if(""!==r[2])throw new Error("Unknown tokens in string starting with "+t.substring(r.index));const s=n.map((t=>t[1])).filter((t=>void 0!==t)),o=new i,u=[o],a={};for(const n of s)if("("===n)u.push(o);else if(")"===n){if(u.length<2)throw new Error("unbalanced input: "+t);const n=u.pop(),r=u.pop();u.push(r.combine(n))}else{const t=u.pop(),r=this.known[n]??(a[n]=a[n]??new e(n));u.push(t.combine(r))}if(1!==u.length)throw new Error("unbalanced input: "+t);return u[0].freevars=a,u[0]}}}}},n={};!function r(e){var s=n[e];if(void 0!==s)return s.exports;var i=n[e]={exports:{}};return t[e](i,i.exports,r),i.exports}(10)})();