(()=>{var t={10:(t,s,e)=>{const n=e(592);t.exports={...n},"undefined"!=typeof window&&(window.SKI=n.SKI)},592:t=>{class s{combine(...t){return t.length>0?new e(this,...t):this}expand(){return this}reduce(t){return null}step(){return null}run(t={},...e){t instanceof s&&(e.unshift(t),t={});let n=e?this.combine(...e):this,r=t.count??0;const i=(t.max??1e3)+r;let o=!1;for(;r<i;r++){const t=n.step();if(!t){o=!0;break}n=t}return{final:o,steps:r,result:n}}isNative(){return!1}equals(t){return this===t}toString(){throw new Error("toString() undefined for generic AST")}}class e extends s{constructor(t,...s){super(),this.fun=t,this.args=s,this.final=!1}combine(...t){return 0===t.length?this:this.fun.combine(...this.args,...t)}expand(){return this.fun.expand().combine(...this.args.map((t=>t.expand())))}step(){if(this.final)return null;if(this.fun.fast){const t=this.fun.reduce(this.args);if(t)return t}const t=this.fun.step();let s=t?1:0;const e=[];for(const t of this.args){const n=t.step();e.push(n??t),n&&s++}if(s)return(t??this.fun).combine(...e);return this.fun.reduce(this.args)||(this.final=!0,null)}equals(t){if(!(t instanceof e))return!1;if(t.args.length!==this.args.length)return!1;if(!this.fun.equals(t.fun))return!1;for(let s=0;s<this.args.length;s++)if(!this.args[s].equals(t.args[s]))return!1;return!0}toString(){return this.fun.toString()+this.args.map((t=>"("+t+")")).join("")}}class n extends s{constructor(t){super(),this.name=t}toString(){return this.name}}class r extends n{constructor(t,s,e,n={}){super(t),this.arity=s,this.impl=e,n.fast&&(this.fast=!0)}reduce(t){if(t.length<this.arity)return null;const s=t.splice(this.arity);return this.impl(...t).combine(...s)}isNative(){return!0}}class i extends s{combine(...t){return t.length?t.shift().combine(...t):this}toString(){return"<empty>"}}class o extends n{constructor(t,s){super(t),this.impl=s}expand(){return this.impl.expand()}step(){return this.impl}toString(){return this.outdated?this.impl.toString():super.toString()}}class a{constructor(){this.known={},this.add("I",[1,t=>t,{fast:!0}],"x -> x"),this.add("K",[2,(t,s)=>t,{fast:!0}],"(x y) -> x"),this.add("S",[3,(t,s,e)=>t.combine(e,s.combine(e))],"(x y z) -> x z (y z)")}add(t,e,n=""){if("string"==typeof e)e=new o(t,this.parse(e));else if(Array.isArray(e))e=new r(t,e[0],e[1],e[2]??{});else{if(!(e instanceof s))throw new Error("add: impl must be an Ast, a string, or a [arity, impl] pair");e=new o(t,e)}return e.note=n,this.known[t]=e,this}remove(t){return this.known[t].outdated=!0,delete this.known[t],this}getTerms(){return{...this.known}}parse(t,s={}){const e=[...t.matchAll(/([()A-Z]|[a-z_][a-z_0-9]*)|\s+|($)/gys)],r=e.pop();if(""!==r[2])throw new Error("Unknown tokens in string starting with "+t.substring(r.index));const o=e.map((t=>t[1])).filter((t=>void 0!==t)),a=new i,h=[a];for(const e of o)if("("===e)h.push(a);else if(")"===e){if(h.length<2)throw new Error("unbalanced input: "+t);const s=h.pop(),e=h.pop();h.push(e.combine(s))}else{const t=h.pop(),r=this.known[e]??(s[e]=s[e]??new n(e));h.push(t.combine(r))}if(1!==h.length)throw new Error("unbalanced input: "+t);return h[0]}}class h{constructor(t,s,e,n,...r){this.expect=t.parse(n,s),this.max=e.max,this.note=e.note,this.args=r.map((e=>t.parse(e,s)))}check(t){const s=t.run({max:this.max},...this.args);return{pass:s.final&&this.expect.equals(s.result),count:s.steps,found:s.result,expected:this.expect}}}class u{constructor(t={},...s){this.env=new a,this.vars={},this.cases=[],this.title=t.title,this.descr=t.descr;for(const t of s)this.add(...t)}add(t={},...s){if("string"==typeof t&&(s.unshift(t),t={}),s.length<1)throw new Error("Too little data for a testcase");return this.cases.push(new h(this.env,this.vars,t,s.shift(),...s)),this}check(t){const s=this.cases.map((s=>s.check(t)));return{pass:s.reduce(((t,s)=>t&&s.pass),!0),details:s}}}a.Quest=u,t.exports={SKI:a,Quest:u}}},s={};!function e(n){var r=s[n];if(void 0!==r)return r.exports;var i=s[n]={exports:{}};return t[n](i,i.exports,e),i.exports}(10)})();