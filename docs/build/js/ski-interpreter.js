/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const ski = __webpack_require__(/*! ./lib/parser */ \"./lib/parser.js\");\nconst quest = __webpack_require__(/*! ./lib/quest */ \"./lib/quest.js\");\n\nmodule.exports = { ...ski, ...quest };\nif (typeof window !== 'undefined') {\n  window.SKI = ski.SKI;\n  window.SKI.Quest = quest.Quest;\n}\n\n\n//# sourceURL=webpack://ski-interpreter/./index.js?");

/***/ }),

/***/ "./lib/expr.js":
/*!*********************!*\
  !*** ./lib/expr.js ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { missingIndices, isSubset } = __webpack_require__(/*! ./util */ \"./lib/util.js\");\n\nconst globalOptions = {\n  terse:   false,\n  max:     1000,\n  maxArgs: 32,\n};\n\nclass Expr {\n  /**\n   *  @descr A generic combinatory logic expression.\n   */\n  constructor () {\n    if (new.target === Expr)\n      throw new Error('Attempt to instantiate abstract class Expr');\n    this.arity = Infinity;\n  }\n\n  /**\n     * postprocess term after parsing. typically return self but may return other term or die\n     * @return {Expr}\n     */\n  postParse () {\n    return this;\n  }\n\n  /**\n     * @desc apply self to zero or more terms and return the resulting term,\n     * without performing any calculations whatsoever\n     * @param {Expr} args\n     * @return {Expr}\n     */\n  apply (...args) {\n    return args.length > 0 ? new App(this, ...args) : this;\n  }\n\n  /**\n     * expand all terms but don't perform any calculations\n     * @return {Expr}\n     */\n  expand () {\n    return this;\n  }\n\n  /**\n   * @desc return all free variables within the term\n   * @return {Set<FreeVar>}\n   */\n  freeVars () {\n    const symbols = this.getSymbols();\n    const out = new Set();\n    for (const [key, _] of symbols) {\n      if (key instanceof FreeVar)\n        out.add(key);\n    }\n    return out;\n  }\n\n  hasLambda () {\n    const sym = this.getSymbols();\n    return sym.has(Expr.lambdaPlaceholder);\n  }\n\n  /**\n   * @desc return all terminal values within the term, that is, values not\n   * composed of other terms. For example, in S(KI)K, the terminals are S, K, I.\n   * @return {Map<Expr, number>}\n   */\n\n  getSymbols () {\n    // TODO better name!\n    return new Map([[this, 1]]);\n  }\n\n  /**\n   * @desc rought estimate of the complexity of the term\n   * @return {number}\n   */\n  weight () {\n    return 1;\n  }\n\n  /**\n   *\n   * @param {{max: number?, maxArgs: number?, bestGuess?: Expr}} options\n   * @return {{\n   *    found: boolean,\n   *    proper: boolean,\n   *    arity: number?,\n   *    linear: boolean?,\n   *    canonical?: Expr,\n   *    skip: Set<number>?\n   * }}\n   */\n  canonize (options = {}) {\n    const max = options.max ?? globalOptions.max;\n    const maxArgs = options.maxArgs ?? globalOptions.maxArgs;\n\n    let expr = this;\n    const jar = [];\n    for (let i = 0; i < maxArgs; i++) {\n      const calc = expr.run({ max });\n      if (!calc.final)\n        break;\n      expr = calc.expr;\n      if (!expr.wantsArgs()) {\n        // found!\n        const symbols = expr.getSymbols();\n        const skip = missingIndices(jar, symbols);\n        const proper = isSubset(symbols.keys(), new Set(jar));\n        const duplicates = [...symbols.entries()].filter(([_, v]) => v > 1);\n        const linear = proper && skip.size === 0 && duplicates.length === 0;\n        return {\n          arity:     i,\n          found:     true,\n          canonical: jar.length ? new Lambda(jar, expr) : expr,\n          proper,\n          linear,\n          ...(skip.size ? { skip } : {}),\n        };\n      }\n      const next = new FreeVar('abcdefgh'[i] ?? 'x' + i);\n      jar.push(next);\n      expr = expr.apply(next);\n    }\n\n    const fallback = { found: false, proper: false };\n    if (options.bestGuess)\n      fallback.canonical = options.bestGuess;\n    return fallback;\n  }\n\n  /**\n   *\n   * @param {{max: number?}}options\n   * @return {{final: boolean, expr: Expr, steps: number}}\n   */\n  rewriteSKI (options = {}) {\n    const opt = {\n      max:   options.max ?? Infinity,\n      steps: 0,\n    };\n    // carrying around a mutable object, but it is what it is\n    const expr = this._rski(opt);\n    return {\n      expr,\n      steps: opt.steps,\n      final: opt.steps === 0,\n    };\n  }\n\n  _rski (options) {\n    return this;\n  }\n\n  /**\n   * @desc Whether the term will reduce further if given more arguments.\n   *       In practice, equivalent to \"starts with a FreeVar\"\n   *       Used by canonize (duh...)\n   * @return {boolean}\n   */\n  wantsArgs () {\n    return true;\n  }\n\n  /**\n     * Apply self to list of given args.\n     * Normally, only native combinators know how to do it.\n     * @param {Expr[]} args\n     * @return {Expr|null}\n     */\n  reduce (args) {\n    return null;\n  }\n\n  /**\n     * Replace all instances of free vars with corresponding values and return the resulting expression.\n     * return null if no changes could be made.\n     * @param {FreeVar} plug\n     * @param {Expr} value\n     * @return {Expr|null}\n     */\n  subst (plug, value) {\n    return null;\n  }\n\n  /**\n     * @desc iterate one step of calculation in accordance with known rules.\n     * @return {{expr: Expr, steps: number, changed: boolean}}\n     */\n  step () { return { expr: this, steps: 0, changed: false } }\n\n  /**\n     * @desc Run uninterrupted sequence of step() applications\n     *       until the expression is irreducible, or max number of steps is reached.\n     *       Default number of steps = 1000.\n     * @param {{max: number?, steps: number?, throw: boolean?}|Expr} [opt]\n     * @param {Expr} args\n     * @return {{expr: Expr, steps: number, final: boolean}}\n     */\n  run (opt = {}, ...args) {\n    if (opt instanceof Expr) {\n      args.unshift(opt);\n      opt = {};\n    }\n    let expr = args ? this.apply(...args) : this;\n    let steps = opt.steps ?? 0;\n    const max = (opt.max ?? globalOptions.max) + steps;\n    let final = false;\n    for (; steps < max; ) {\n      const next = expr.step();\n      if (!next.changed) {\n        final = true;\n        break;\n      }\n      steps += next.steps;\n      expr = next.expr;\n    }\n    if (opt.throw && !final)\n      throw new Error('Failed to compute expression in ' + max + ' steps');\n    return { final, steps, expr };\n  }\n\n  /**\n     * Execute step() while possible, yielding a brief description of events after each step.\n     * Mnemonics: like run() but slower.\n     * @param {{max: number?}} options\n     * @return {IterableIterator<{final: boolean, expr: Expr, steps: number}>}\n     */\n  * walk (options = {}) {\n    const max = options.max ?? Infinity;\n    let steps = 0;\n    let expr = this;\n    let final = false;\n\n    while (steps < max) {\n      const next = expr.step();\n      if (!next.changed)\n        final = true;\n      yield { expr, steps, final };\n      if (final)\n        break;\n      steps += next.steps;\n      expr = next.expr;\n    }\n  }\n\n  /**\n     *\n     * @param {Expr} other\n     * @return {boolean}\n     */\n  equals (other) {\n    return this === other;\n  }\n\n  expect (other) {\n    if (!(other instanceof Expr))\n      throw new Error('Attempt to expect a combinator to equal something else: ' + other);\n    if (this.equals(other))\n      return;\n\n    // TODO wanna use AssertionError but webpack doesn't recognize it\n    // still the below hack works for mocha-based tests.\n    const poorMans = new Error('Found term ' + this + ' but expected ' + other);\n    poorMans.expected = other.toString();\n    poorMans.actual = this.toString();\n    throw poorMans;\n  }\n\n  /**\n   * @param {{terse: boolean?}} options\n   * @return {string} string representation of the expression\n   */\n  toString (options = {}) {\n    // uncomment the following line if you want to debug the parser with prints\n    // return this.constructor.name\n    throw new Error( 'No toString() method defined in class ' + this.constructor.name );\n  }\n\n  /**\n   *\n   * @return {boolean}\n   */\n  needsParens () {\n    return false;\n  }\n\n  /**\n   *\n   * @return {string}\n   */\n  toJSON () {\n    return this.expand().toString({ terse: false });\n  }\n}\n\n/**\n *   Constants that define when whitespace between terms may be omitted in App.toString()\n */\nconst BITS = 4;\nconst [T_UNKNOWN, T_PARENS, T_UPPER, T_LOWER]\n    = (function * () { for (let i = 0; ; yield i++); })();\nconst canLump = new Set([\n  (T_PARENS  << BITS) + T_PARENS,\n  (T_PARENS  << BITS) + T_UPPER,\n  (T_UPPER   << BITS) + T_PARENS,\n  (T_UPPER   << BITS) + T_UPPER,\n  (T_UPPER   << BITS) + T_LOWER,\n  (T_LOWER   << BITS) + T_PARENS,\n  (T_UNKNOWN << BITS) + T_PARENS,\n]);\n\nclass App extends Expr {\n  /**\n   * @desc Application of fun() to args.\n   * Never ever use new App(fun, ...args) directly, use fun.apply(...args) instead.\n   * @param {Expr} fun\n   * @param {Expr} args\n   */\n  constructor (fun, ...args) {\n    if (args.length === 0)\n      throw new Error('Attempt to create an application with no arguments (likely interpreter bug)');\n    super();\n    this.fun = fun;\n    this.args = args;\n    this.final = false;\n  }\n\n  weight () {\n    return this.args.reduce((acc, x) => acc + x.weight(), this.fun.weight());\n  }\n\n  getSymbols () {\n    const out = this.fun.getSymbols();\n    for (const term of this.args) {\n      for (const [key, value] of term.getSymbols())\n        out.set(key, (out.get(key) ?? 0) + value);\n    }\n    return out;\n  }\n\n  wantsArgs () {\n    return this.fun.wantsArgs();\n  }\n\n  apply (...args) {\n    if (args.length === 0)\n      return this;\n    return this.fun.apply( ...this.args, ...args);\n  }\n\n  expand () {\n    return this.fun.expand().apply(...this.args.map(x => x.expand()));\n  }\n\n  canonize (options = {}) {\n    const [fun, arg] = this.split().map(x => x.canonize(options).canonical);\n    return super.canonize({\n      ...options,\n      ...(fun && arg ? { bestGuess: fun.apply(arg) } : {})\n    });\n  }\n\n  subst (plug, value) {\n    const fun = this.fun.subst(plug, value);\n    let change = fun === null ? 0 : 1;\n    const args = [];\n    for (const x of this.args) {\n      const next = x.subst(plug, value);\n      if (next === null)\n        args.push(x);\n      else {\n        args.push(next);\n        change++;\n      }\n    }\n\n    return change ? (fun ?? this.fun).apply(...args) : null;\n  }\n\n  /**\n   * @return {{expr: Expr, steps: number}}\n   */\n\n  step () {\n    // normal reduction order: first try root, then at most 1 step\n    if (!this.final) {\n      const reduced = this.fun.reduce(this.args);\n      if (reduced)\n        return { expr: reduced, steps: 1, changed: true };\n\n      // now try recursing\n\n      const fun = this.fun.step();\n      if (fun.changed)\n        return { expr: fun.expr.apply(...this.args), steps: fun.steps, changed: true };\n\n      for (let i = 0; i < this.args.length; i++) {\n        const next = this.args[i].step();\n        if (!next.changed)\n          continue;\n        const args = this.args.slice();\n        args[i] = next.expr;\n        return { expr: this.fun.apply(...args), steps: next.steps, changed: true };\n      }\n    }\n    this.final = true;\n    return { expr: this, steps: 0, changed: false };\n  }\n\n  split () {\n    // pretend we are an elegant (cons fun arg) and not a sleazy imperative array\n    const args = this.args.slice();\n    const last = args.pop();\n    return [this.fun.apply(...args), last];\n  }\n\n  /**\n   * @desc Convert the expression to SKI combinatory logic\n   * @return {Expr}\n   */\n\n  _rski (options) {\n    if (options.steps >= options.max)\n      return this;\n    return this.fun._rski(options).apply(...this.args.map(x => x._rski(options)));\n  }\n\n  equals (other) {\n    if (!(other instanceof App))\n      return false;\n    if (other.args.length !== this.args.length)\n      return false;\n    if (!this.fun.equals(other.fun))\n      return false;\n    for (let i = 0; i < this.args.length; i++) {\n      if (!this.args[i].equals(other.args[i]))\n        return false;\n    }\n    return true;\n  }\n\n  toString (opt = {}) {\n    if (opt.terse ?? globalOptions.terse) {\n      const out = [];\n      let oldType = 0;\n      // stupid ad-hoc state machine, see above for constant definitions\n      for (const term of [this.fun, ...this.args]) {\n        let s = term.toString(opt);\n        let newType = T_UNKNOWN;\n        if (s.match(/^[A-Z]$/))\n          newType = T_UPPER;\n        else if (s.match(/^[a-z][a-z_0-9]*$/))\n          newType = T_LOWER;\n        else if (s.match(/^[0-9]+$/))\n          // no special treatment for numerals, skip\n          ;\n        else if (out.length !== 0 || term.needsParens()) {\n          s = '(' + s + ')';\n          newType = T_PARENS;\n        }\n        if (!canLump.has((oldType << BITS) | newType) && out.length > 0)\n          out.push(' ');\n        out.push(s);\n        oldType = newType;\n      }\n      return out.join('');\n    } else {\n      const root = this.fun.needsParens() ? '(' + this.fun + ')' : this.fun + '';\n      return root + this.args.map(x => '(' + x + ')').join('');\n    }\n  }\n}\n\nclass Named extends Expr {\n  /**\n     * @desc a constant named 'name'\n     * @param {String} name\n     */\n  constructor (name) {\n    super();\n    if (typeof name !== 'string' || name.length === 0)\n      throw new Error('Attempt to create a named term with improper name');\n    this.name = name;\n  }\n\n  toString () {\n    return this.name;\n  }\n}\n\nlet freeId = 0;\n\nclass FreeVar extends Named {\n  constructor (name) {\n    super(name);\n    this.id = ++freeId;\n  }\n\n  subst (plug, value) {\n    if (this === plug)\n      return value;\n    return null;\n  }\n\n  weight () {\n    return 0;\n  }\n\n  wantsArgs () {\n    return false;\n  }\n}\n\n/**\n * @typedef {function(Expr): Expr | AnyArity} AnyArity\n */\n\nclass Native extends Named {\n  /**\n   * @desc A term named 'name' that converts next 'arity' arguments into\n   *       an expression returned by 'impl' function\n   *       If an apply: Expr=>Expr|null function is given, it will be attempted upon application\n   *       before building an App object. This allows to plug in argument coercions,\n   *       e.g. instantly perform a numeric operation natively if the next term is a number.\n   * @param {String} name\n   * @param {AnyArity} impl\n   * @param {{note: string?, arity: number?, canonize: boolean?, apply: function(Expr):(Expr|null) }} [opt]\n   */\n  constructor (name, impl, opt = {}) {\n    super(name);\n    // setup essentials\n    this.impl  = impl;\n    if (opt.apply)\n      this.onApply = opt.apply;\n    this.arity = opt.arity ?? 1;\n\n    // try to bootstrap and guess some of our properties\n    const guess = (opt.canonize ?? true) ? this.canonize() : { found: false };\n\n    if (!opt.arity)\n      this.arity = guess.arity || 1;\n\n    this.note = opt.note ?? guess.canonical?.toString({ terse: true });\n  }\n\n  apply (...args) {\n    if (this.onApply && args.length >= 1) {\n      if (typeof this.onApply !== 'function') {\n        throw new Error('Native combinator ' + this + ' has an invalid onApply property  of type'\n          + typeof this.onApply + ': ' + this.onApply);\n      }\n      const subst = this.onApply(args[0]);\n      if (subst instanceof Expr)\n        return subst.apply(...args.slice(1));\n    }\n    return super.apply(...args);\n  }\n\n  _rski (options) {\n    if (this === native.I || this === native.K || this === native.S || (options.steps >= options.max))\n      return this;\n    const canon = this.canonize().canonical;\n    if (!canon)\n      return this;\n    options.steps++;\n    return canon._rski(options);\n  }\n\n  reduce (args) {\n    if (args.length < this.arity)\n      return null;\n    let egde = 0;\n    let step = this.impl;\n    while (typeof step === 'function') {\n      if (egde >= args.length)\n        return null;\n      step = step(args[egde++]);\n    }\n    if (!(step instanceof Expr))\n      throw new Error('Native combinator ' + this + ' reduced to a non-expression: ' + step);\n    return step.apply(...args.slice(egde));\n  }\n\n  toJSON () {\n    return 'Native:' + this.name;\n  }\n}\n\nconst native = {};\nfunction addNative (name, impl, opt) {\n  native[name] = new Native(name, impl, opt);\n}\n\nclass Lambda extends Expr {\n  /**\n     * @param {FreeVar|FreeVar[]} arg\n     * @param {Expr} impl\n     */\n  constructor (arg, impl) {\n    if (Array.isArray(arg)) {\n      // check args before everything\n      if (arg.length === 0)\n        throw new Error('empty argument list in lambda constructor');\n\n      const [my, ...tail] = arg;\n      const known = new Set([my.name]);\n\n      while (tail.length > 0) {\n        const last = tail.pop();\n        if (known.has(last.name))\n          throw new Error('Duplicate free var name ' + last + ' in lambda expression');\n        known.add(last.name);\n\n        // TODO keep track of arity to speed up execution\n        impl = new Lambda(last, impl);\n      }\n      arg = my;\n    }\n\n    super();\n\n    // localize argument variable as it may appear elsewhere\n    const local = new FreeVar(arg.name);\n    this.arg = local;\n    this.impl = impl.subst(arg, local) ?? impl;\n    this.arity = 1;\n  }\n\n  getSymbols () {\n    const out = this.impl.getSymbols();\n    out.delete(this.arg);\n    out.set(Expr.lambdaPlaceholder, (out.get(Expr.lambdaPlaceholder) ?? 0) + 1);\n    return out;\n  }\n\n  weight () {\n    return this.impl.weight() + 1;\n  }\n\n  reduce (input) {\n    if (input.length === 0)\n      return null;\n\n    const [head, ...tail] = input;\n\n    return (this.impl.subst(this.arg, head) ?? this.impl).apply(...tail);\n  }\n\n  subst (plug, value) {\n    if (plug === this.arg)\n      return null;\n    const change = this.impl.subst(plug, value);\n    if (change)\n      return new Lambda(this.arg, change);\n    return null;\n  }\n\n  expand () {\n    return new Lambda(this.arg, this.impl.expand());\n  }\n\n  _rski (options) {\n    const impl = this.impl._rski(options);\n    if (options.steps >= options.max)\n      return new Lambda(this.arg, impl);\n    options.steps++;\n    if (impl === this.arg)\n      return native.I;\n    if (!impl.getSymbols().has(this.arg))\n      return native.K.apply(impl);\n    if (impl instanceof App) {\n      const [fst, snd] = impl.split();\n      // try eta reduction\n      if (snd === this.arg && !fst.getSymbols().has(this.arg))\n        return fst._rski(options);\n      // fall back to S\n      return native.S.apply(\n        (new Lambda(this.arg, fst))._rski(options),\n        (new Lambda(this.arg, snd))._rski(options)\n      );\n    }\n    throw new Error('Don\\'t know how to convert to SKI' + this);\n  }\n\n  equals (other) {\n    if (!(other instanceof Lambda))\n      return false;\n\n    const t = new FreeVar('t');\n\n    return other.reduce([t]).equals(this.reduce([t]));\n  }\n\n  toString (opt = {}) {\n    return this.arg + '->' + this.impl.toString(opt);\n  }\n\n  needsParens () {\n    return true;\n  }\n}\n\nclass Church extends Native {\n  constructor (n) {\n    const p = Number.parseInt(n);\n    if (!(p >= 0))\n      throw new Error('Church number must be a non-negative integer');\n    const name = '' + p;\n    const impl = x => y => {\n      let expr = y;\n      for (let i = p; i-- > 0; )\n        expr = x.apply(expr);\n      return expr;\n    };\n\n    super(name, impl, { arity: 2, canonize: false, note: name });\n\n    this.n = p;\n    this.arity = 2;\n  }\n\n  equals (other) {\n    if (other instanceof Church)\n      return this.n === other.n;\n    return false;\n  }\n}\n\nclass Alias extends Named {\n  /**\n   * @desc An existing expression under a different name.\n   * @param {String} name\n   * @param {Expr} impl\n   * @param {{canonize: boolean?, max: number?, maxArgs: number?, note: string?, terminal: boolean?}} [options]\n   */\n  constructor (name, impl, options = {}) {\n    super(name);\n    this.impl = impl;\n\n    if (options.note)\n      this.note = options.note;\n\n    const guess = options.canonize\n      ? impl.canonize({ max: options.max, maxArgs: options.maxArgs })\n      : { found: false };\n    this.arity = (guess.found && guess.proper && guess.arity) || 0;\n    this.proper = guess.proper ?? false;\n    this.terminal = options.terminal ?? this.proper;\n    this.canonical = guess.canonical;\n  }\n\n  getSymbols () {\n    return this.terminal ? new Map([[this, 1]]) : this.impl.getSymbols();\n  }\n\n  weight () {\n    return this.terminal ? 1 : this.impl.weight();\n  }\n\n  expand () {\n    return this.impl.expand();\n  }\n\n  subst (plug, value) {\n    return this.impl.subst(plug, value);\n  }\n\n  /**\n   *\n   * @return {{expr: Expr, steps: number}}\n   */\n  step () {\n    // arity known = waiting for args to expand\n    if (this.arity > 0)\n      return { expr: this, steps: 0, changed: false };\n    // expanding is a change but it takes 0 steps\n    return { expr: this.impl, steps: 0, changed: true };\n  }\n\n  reduce (args) {\n    if (args.length < this.arity)\n      return null;\n    return this.impl.apply(...args);\n  }\n\n  wantsArgs () {\n    return this.impl.wantsArgs();\n  }\n\n  equals (other) {\n    return other.equals(this.impl);\n  }\n\n  _rski (options) {\n    return this.impl._rski(options);\n  }\n\n  toString (opt) {\n    return this.outdated ? this.impl.toString(opt) : super.toString(opt);\n  }\n\n  needsParens () {\n    return this.outdated ? this.impl.needsParens() : false;\n  }\n}\n\n// declare native combinators\naddNative('I', x => x);\naddNative('K', x => _ => x);\naddNative('S', x => y => z => x.apply(z, y.apply(z)));\naddNative('B', x => y => z => x.apply(y.apply(z)));\naddNative('C', x => y => z => x.apply(z).apply(y));\naddNative('W', x => y => x.apply(y).apply(y));\n\naddNative('+', x => y => z => y.apply(x.apply(y, z)), {\n  note:  'n->n+1 or SB',\n  apply: arg => arg instanceof Church ? new Church(arg.n + 1) : null\n});\n\n// A global value meaning \"lambda is used somewhere in this expression\"\n// Can't be used (at least for now) to construct lambda expressions, or anything at all.\n// See also getSymbols().\nExpr.lambdaPlaceholder = new Native('->', x => x, {\n  arity:    1,\n  canonize: false,\n  note:     'Lambda placeholder',\n  apply:    x => { throw new Error('Attempt to use a placeholder in expression') }\n});\n\nmodule.exports = { Expr, App, FreeVar, Lambda, Native, Alias, Church, globalOptions, native };\n\n\n//# sourceURL=webpack://ski-interpreter/./lib/expr.js?");

/***/ }),

/***/ "./lib/parser.js":
/*!***********************!*\
  !*** ./lib/parser.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Combinatory logic simulator\n */\n\nconst { Tokenizer, restrict } = __webpack_require__(/*! ./util */ \"./lib/util.js\");\nconst { globalOptions, Expr, App, FreeVar, Lambda, Native, Alias, Church, native } = __webpack_require__(/*! ./expr */ \"./lib/expr.js\");\n\nclass Empty extends Expr {\n  apply (...args) {\n    return args.length ? args.shift().apply(...args) : this;\n  }\n\n  postParse () {\n    throw new Error('Attempt to use empty expression () as a term');\n  }\n}\n\nclass PartialLambda extends Empty {\n  // TODO mutable! rewrite ro when have time\n  constructor (term, known = {}) {\n    super();\n    this.impl = new Empty();\n    if (term instanceof FreeVar)\n      this.terms = [term];\n    else if (term instanceof PartialLambda) {\n      if (!(term.impl instanceof FreeVar))\n        throw new Error('Expected FreeVar->...->FreeVar->Expr');\n      this.terms = [...term.terms, term.impl];\n    } else\n      throw new Error('Expected FreeVar or PartialLambda');\n  }\n\n  apply (term, ...tail) {\n    if (term === null || tail.length !== 0 )\n      throw new Error('bad syntax in partial lambda expr');\n    this.impl = this.impl.apply(term);\n    return this;\n  }\n\n  postParse () {\n    return new Lambda(this.terms, this.impl);\n  }\n\n  // uncomment if debugging with prints\n  /* toString () {\n    return this.terms.join('->') + '->' + (this.impl ?? '???');\n  } */\n}\n\nconst combChars = new Tokenizer(\n  '[()]', '[A-Z]', '[a-z_][a-z_0-9]*', '\\\\b[0-9]+\\\\b', '->', '\\\\+'\n);\n\nclass SKI {\n  /**\n   *\n   * @param {{\n   *    allow: string?,\n   *    numbers: boolean?,\n   *    lambdas: boolean?,\n   *    terms: { [key: string]: Expr|string}?,\n   *    annotate: boolean?,\n   * }} [options]\n   */\n  constructor (options = {}) {\n    this.annotate = options.annotate ?? false;\n    this.known = { ...native };\n    this.hasNumbers = true;\n    this.hasLambdas = true;\n    this.allow = new Set(Object.keys(this.known));\n\n    // Import terms, if any. Omit native ones\n    for (const name in options.terms ?? {}) {\n      // Native terms already handled by allow\n      if (!options.terms[name].match(/^Native:/))\n        this.add(name, options.terms[name]);\n    }\n\n    // Finally, impose restrictions\n    // We must do it after recreating terms, or else terms reliant on forbidden terms will fail\n    this.hasNumbers = options.numbers ?? true;\n    this.hasLambdas = options.lambdas ?? true;\n    if (options.allow)\n      this.restrict(options.allow);\n  }\n\n  /**\n   *\n   * @param {Alias|String} term\n   * @param {Expr|String|[number, function(...Expr): Expr, {note: string?, fast: boolean?}]} [impl]\n   * @param {String} [note]\n   * @return {SKI} chainable\n   */\n  add (term, impl, note ) {\n    if (typeof term === 'string') {\n      if (typeof impl === 'string')\n        term = new Alias(term, this.parse(impl), { canonize: true });\n      else if (impl instanceof Expr)\n        term = new Alias(term, impl, { canonize: true });\n      else\n        throw new Error('add: term must be an Alias or a string and impl must be an Expr or a string');\n    } else if (term instanceof Alias)\n      term = new Alias(term.name, term.impl, { canonize: true });\n\n    // This should normally be unreachable but let's keep just in case\n    if (!(term instanceof Alias))\n      throw new Error('add: term must be an Alias or a string (accompanied with an implementation)');\n\n    if (this.annotate && note === undefined && term.canonical)\n      note = term.canonical.toString({ terse: true });\n    if (note !== undefined)\n      term.note = note;\n\n    this.known['' + term] = term;\n    this.allow.add('' + term);\n\n    return this;\n  }\n\n  maybeAdd (name, impl) {\n    if (this.known[name])\n      this.allow.add(name);\n    else\n      this.add(name, impl);\n    return this;\n  }\n\n  /**\n   * Restrict the interpreter to given terms. Terms prepended with '+' will be added\n   * and terms preceeded with '-' will be removed.\n   * @example ski.restrict('SK') // use the basis\n   * @example ski.restrict('+I') // allow I now\n   * @example ski.restrict('-SKI +BCKW' ); // switch basis\n   * @example ski.restrict('-foo -bar'); // forbid some user functions\n   * @param {string} spec\n   * @return {SKI} chainable\n   */\n  restrict (spec) {\n    this.allow = restrict(this.allow, spec);\n    return this;\n  }\n\n  /**\n   *\n   * @param {string} spec\n   * @return {string}\n   */\n  showRestrict (spec = '+') {\n    const out = [];\n    let prevShort = true;\n    for (const term of [...restrict(this.allow, spec)].sort()) {\n      const nextShort = term.match(/^[A-Z]$/);\n      if (out.length && !(prevShort && nextShort))\n        out.push(' ');\n      out.push(term);\n      prevShort = nextShort;\n    }\n    return out.join('');\n  }\n\n  /**\n   *\n   * @param {String} name\n   * @return {SKI}\n   */\n  remove (name) {\n    this.known[name].outdated = true;\n    delete this.known[name];\n    this.allow.delete(name);\n    return this;\n  }\n\n  /**\n   *\n   * @return {{[key:string]: Native|Alias}}\n   */\n  getTerms () {\n    const out = {};\n    for (const name of Object.keys(this.known)) {\n      if (this.allow.has(name))\n        out[name] = this.known[name];\n    }\n    return out;\n  }\n\n  /**\n   *\n   * @param {string} source\n   * @param {{[keys: string]: Expr}} vars\n   * @param {{numbers: boolean?, lambdas: boolean?, allow: string?}} options\n   * @return {Expr}\n   */\n  parse (source, vars = {}, options = {}) {\n    const lines = source.replace(/\\/\\/[^\\n]*$/gm, '')\n      .split(/\\s*;[\\s;]*/).filter( s => s.match(/\\S/));\n\n    const jar = { ...vars };\n\n    let expr = new Empty();\n    for (const item of lines) {\n      const [_, save, str] = item.match(/^(?:\\s*([A-Z]|[a-z][a-z_0-9]*)\\s*=\\s*)?(.*)$/s);\n      if (expr instanceof Alias)\n        expr.outdated = true;\n      expr = this.parseLine(str, jar, options);\n\n      if (save !== undefined) {\n        if (jar[save] !== undefined)\n          throw new Error('Attempt to redefine a known term: ' + save);\n        expr = new Alias(save, expr);\n        jar[save] = expr;\n      }\n\n      // console.log('parsed line:', item, '; got:', expr,'; jar now: ', jar);\n    }\n\n    // reimport free variables, so that co-parsing x(y(z)) and z(x(y)) with the same jar\n    //     results in _equal_ free vars and not just ones with the same name\n    for (const name in jar) {\n      if (!vars[name] && jar[name] instanceof SKI.classes.FreeVar)\n        vars[name] = jar[name];\n    }\n\n    return expr;\n  }\n\n  /**\n   *\n   * @param {String} source S(KI)I\n   * @param {{[keys: string]: Expr}} vars\n   * @param {{numbers: boolean?, lambdas: boolean?, allow: string?}} options\n   * @return {Expr} parsed expression\n   */\n  parseLine (source, vars = {}, options = {}) {\n    const opt = {\n      numbers: options.numbers ?? this.hasNumbers,\n      lambdas: options.lambdas ?? this.hasLambdas,\n      allow:   restrict(this.allow, options.allow),\n    };\n    // make sure '+' usage is in sync with numerals\n    opt.numbers ? opt.allow.add('+') : opt.allow.delete('+');\n\n    const tokens = combChars.split(source);\n\n    const empty = new Empty();\n    /** @type {Expr[]} */\n    const stack = [empty];\n\n    // TODO each token should carry along its position in source\n    for (const c of tokens) {\n      // console.log(\"parseLine: found \"+c+\"; stack =\", stack.join(\", \"));\n      if (c === '(')\n        stack.push(empty);\n      else if (c === ')') {\n        if (stack.length < 2)\n          throw new Error('unbalanced input: extra closing parenthesis' + source);\n        const x = stack.pop().postParse();\n        const f = stack.pop();\n        stack.push(f.apply(x));\n      } else if (c === '->') {\n        if (!opt.lambdas)\n          throw new Error('Lambdas not supported, allow them explicitly');\n        stack.push(new PartialLambda(stack.pop(), vars));\n      } else if (c.match(/^[0-9]+$/)) {\n        if (!opt.numbers)\n          throw new Error('Church numbers not supported, allow them explicitly');\n        const f = stack.pop();\n        stack.push(f.apply(new Church(c)));\n      } else {\n        const f = stack.pop();\n        if (!vars[c] && this.known[c] && !opt.allow.has(c)) {\n          throw new Error('Term \\'' + c + '\\' is not in the restricted set '\n            + [...opt.allow].sort().join(' '));\n        }\n        // look in temp vars first, then in known terms, then fallback to creating free var\n        const x = vars[c] ?? this.known[c] ?? (vars[c] = new FreeVar(c));\n        stack.push(f.apply(x));\n      }\n    }\n\n    if (stack.length !== 1) {\n      throw new Error('unbalanced input: missing '\n          + (stack.length - 1) + ' closing parenthesis:' + source);\n    }\n\n    return stack.pop().postParse();\n  }\n\n  toJSON () {\n    return {\n      allow:    this.showRestrict('+'),\n      numbers:  this.hasNumbers,\n      lambdas:  this.hasLambdas,\n      terms:    this.getTerms(),\n      annotate: this.annotate,\n    }\n  }\n}\n\n// Create shortcuts for common terms\n/**\n * Create free var(s) for subsequent use\n * @param {String} names\n * @return {FreeVar[]}\n */\nSKI.free = (...names) => names.map(s => new FreeVar(s));\n\n/**\n * Convert a number to Church encoding\n * @param {number} n\n * @return {Church}\n */\nSKI.church = n => new Church(n);\nSKI.classes = { Expr, Native, Alias, FreeVar, Lambda, Church };\n\n/**\n *\n * @type {{[key: string]: Native}}\n */\n\nfor (const name in native)\n  SKI[name] = native[name];\nSKI.native = native;\nSKI.options = globalOptions;\nSKI.lambdaPlaceholder = Expr.lambdaPlaceholder;\n\nmodule.exports = { SKI };\n\n\n//# sourceURL=webpack://ski-interpreter/./lib/parser.js?");

/***/ }),

/***/ "./lib/quest.js":
/*!**********************!*\
  !*** ./lib/quest.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { SKI } = __webpack_require__(/*! ./parser */ \"./lib/parser.js\");\nconst { Expr, FreeVar, Alias, Lambda } = SKI.classes;\n\n/**\n * @typedef {{\n *   pass: boolean,\n *   reason: string?,\n *   steps: number,\n *   start: Expr,\n *   found: Expr,\n *   expected: Expr,\n *   note: string?,\n *   args: Expr[],\n *   case: Case\n * }} CaseResult\n */\n\nclass Quest {\n  /**\n   * @description A combinator problem with a set of test cases for the proposed solution.\n   * @param {{\n   *    title: string?,\n   *    descr: string?,\n   *    subst: string?,\n   *    allow: string?,\n   *    numbers: boolean?,\n   *    vars: string[]?,\n   *    engine: SKI?,\n   *    engineFull: SKI?,\n   *    cases: [{max: number?, note: string?, feedInput: boolean, lambdas: boolean?}|string[], ...string[][]]?\n   * }} options\n   */\n  constructor (options = {}) {\n    const { input, vars, cases, allow, numbers, lambdas, subst, engine, engineFull, ...meta } = options;\n\n    //\n    this.engine = engine ?? new SKI();\n    this.engineFull = engineFull ?? new SKI();\n    this.restrict = { allow, numbers: numbers ?? false, lambdas: lambdas ?? false };\n    this.vars = {};\n    this.subst = Array.isArray(subst) ? subst : [subst ?? 'phi'];\n\n    // options.vars is a list of expressions.\n    // we suck all free variables + all term declarations from there into this.vars\n    // to feed it later to every case's parser.\n    for (const term of vars ?? []) {\n      const expr = this.engineFull.parse(term, this.vars);\n      if (expr instanceof SKI.classes.Alias)\n        this.vars[expr.name] = new Alias(expr.name, expr.impl, { terminal: true, canonize: false });\n        // Canonized aliases won't expand with insufficient arguments,\n        // causing correct solutions to fail, so alas...\n    }\n\n    this.input = [];\n    for (const term of Array.isArray(input) ? input : [input])\n      this.addInput(term);\n    if (!this.input.length)\n      throw new Error('Quest needs at least one input placeholder');\n    if (subst)\n      this.input[0].fancy = this.subst[0];\n\n    this.varsFull = { ...this.vars };\n    for (const term of this.input) {\n      if (term.name in this.varsFull)\n        throw new Error('input placeholder name is duplicated or clashes with vars: ' + term.name);\n      this.varsFull[term.name] = term.placeholder;\n    }\n\n    this.cases = [];\n    this.title = meta.title;\n    meta.descr = list2str(meta.descr);\n    this.descr = meta.descr;\n    this.meta = meta;\n\n    for (const c of cases ?? [])\n      this.add(...c);\n  }\n\n  /**\n   *   Display allowed terms based on what engine thinks of this.vars + this.restrict.allow\n   *   @return {string}\n   */\n  allowed () {\n    const allow = this.restrict.allow ?? '';\n    const vars = Object.keys(this.vars).sort();\n    // In case vars are present and restrictions aren't, don't clutter the output with all the known terms\n    return allow\n      ? this.engine.showRestrict(allow + '+' + vars.join(' '))\n      : vars.map( s => '+' + s).join(' ');\n  }\n\n  addInput (term) {\n    if (typeof term === 'string')\n      term = { name: term };\n    if (!term.name)\n      throw new Error('input placeholder must have a name');\n\n    [term.placeholder] = SKI.free(term.name);\n    // TODO more checks\n    this.input.push(term);\n  }\n\n  /**\n   *\n   * @param {{} | string} opt\n   * @param {string} terms\n   * @return {Quest}\n   */\n  add (opt, ...terms) {\n    if (typeof opt === 'string') {\n      terms.unshift(opt);\n      opt = {};\n    } else\n      opt = { ...opt };\n\n    opt.engine = opt.engine  ?? this.engineFull;\n    opt.vars = opt.vars ?? this.varsFull;\n\n    const input = this.input.map( t => t.placeholder );\n    this.cases.push(\n      opt.linear\n        ? new LinearCase(input, opt, terms)\n        : new ExprCase(input, opt, terms)\n    );\n    return this;\n  }\n\n  /**\n   * @description Statefully parse a list of strings into expressions or fancy aliases thereof.\n   * @param {string[]} input\n   * @return {{terms: Expr[], weight: number}}\n   */\n  prepare (...input) {\n    if (input.length !== this.input.length)\n      throw new Error('Solutions provided ' + input.length + ' terms where ' + this.input.length + ' are expected');\n\n    let weight = 0;\n    const prepared = [];\n    const jar = { ...this.vars };\n    for (let i = 0; i < input.length; i++) {\n      const spec = this.input[i];\n      const impl = this.engine.parse(input[i], jar, {\n        allow:   spec.allow ?? this.restrict.allow,\n        numbers: spec.numbers ?? this.restrict.numbers,\n        lambdas: spec.lambdas ?? this.restrict.lambdas,\n      });\n      weight += impl.weight();\n      const expr = impl instanceof FreeVar\n        ? impl\n        : new Alias(spec.fancy ?? spec.name, impl, { terminal: true, canonize: false });\n      jar[spec.name] = expr;\n      prepared.push(expr);\n    }\n    return {\n      prepared,\n      weight,\n    };\n  }\n\n  /**\n   *\n   * @param {string} input\n   * @return {{\n   *             expr: Expr?,\n   *             pass: boolean,\n   *             details: CaseResult[],\n   *             exception: Error?,\n   *             steps: number,\n   *             input: Expr[]|string[],\n   *             weight: number?\n   *         }}\n   */\n  check (...input) {\n    try {\n      const { prepared, weight } = this.prepare(...input);\n      const details = this.cases.map( c => c.check(...prepared) );\n      const pass = details.reduce((acc, val) => acc && val.pass, true);\n      const steps = details.reduce((acc, val) => acc + val.steps, 0);\n      return {\n        expr:  prepared[0],\n        input: prepared,\n        pass,\n        steps,\n        details,\n        weight,\n      };\n    } catch (e) {\n      return { pass: false, details: [], exception: e, steps: 0, input };\n    }\n  }\n\n  /**\n     *\n     * @return {TestCase[]}\n     */\n  show () {\n    return [...this.cases];\n  }\n}\n\nclass Case {\n  constructor (input, options) {\n    this.max = options.max ?? 1000;\n    this.note = options.note;\n    this.vars = { ...(options.vars ?? {}) }; // shallow copy to avoid modifying the original\n    this.input = input;\n    this.engine = options.engine;\n  }\n\n  parse (src) {\n    return new Lambda(this.input, this.engine.parse(src, this.vars));\n  }\n\n  /**\n   * @param {Expr} expr\n   * @return {CaseResult}\n   */\n  check ( ...expr ) {\n    throw new Error('not implemented');\n  }\n}\n\nclass ExprCase extends Case {\n  /**\n   * @param {FreeVar[]} input\n   * @param {{\n   *    max: number?,\n   *    note: string?,\n   *    vars: {string: Expr}?,\n   *    engine: SKI?\n   * }} options\n   * @param {[e1: string, e2: string]} terms\n   */\n  constructor (input, options, terms) {\n    if (terms.length !== 2)\n      throw new Error('Case accepts exactly 2 strings');\n\n    super(input, options);\n\n    [this.e1, this.e2] = terms.map(src => this.parse(src));\n  }\n\n  check (...expr) {\n    // we do it the fancy way and instead of just \"apply\" to avoid\n    // displaying (foo->foo this that)(user input) as 1st step\n    const subst = (outer, inner) => outer.reduce(inner) ?? outer.apply(...inner);\n\n    const start = subst(this.e1, expr);\n    const r1 = start.run({ max: this.max });\n    const r2 = subst(this.e2, expr).expand().run({ max: this.max });\n    let reason = null;\n    if (!r1.final || !r2.final)\n      reason = 'failed to reach normal form in ' + this.max + ' steps';\n    else if (!r1.expr.equals(r2.expr))\n      reason = 'expected: ' + r2.expr;\n\n    return {\n      pass:     !reason,\n      reason,\n      steps:    r1.steps,\n      start,\n      found:    r1.expr,\n      expected: r2.expr,\n      note:     this.note,\n      args:     expr,\n      case:     this,\n    };\n  }\n}\n\nclass LinearCase extends Case {\n  // test that an expression uses all of its inputs exactly once\n  constructor (input, options, terms) {\n    super(input, options);\n    this.expr = this.parse(terms[0]);\n  }\n\n  check (...expr) {\n    const start = this.expr.apply(...expr);\n    const r = start.run({ max: this.max });\n    const arity = r.expr.canonize();\n    const reason = arity.linear\n      ? null\n      : 'expected a linear expression, i.e. such that uses all inputs exactly once';\n    return {\n      pass:  !reason,\n      reason,\n      steps: r.steps,\n      start,\n      found: r.expr,\n      case:  this,\n      note:  this.note,\n      args:  expr,\n    }\n  }\n}\n\nfunction list2str (str) {\n  if (str === undefined)\n    return str;\n  return Array.isArray(str) ? str.join(' ') : '' + str;\n}\n\nmodule.exports = { Quest };\n\n\n//# sourceURL=webpack://ski-interpreter/./lib/quest.js?");

/***/ }),

/***/ "./lib/util.js":
/*!*********************!*\
  !*** ./lib/util.js ***!
  \*********************/
/***/ ((module) => {

eval("class Tokenizer {\n  constructor (...terms) {\n    const src = '$|(\\\\s+)|' + terms\n      .map(s => '(?:' + s + ')')\n      .sort((a, b) => b.length - a.length)\n      .join('|');\n    this.rex = new RegExp(src, 'gys');\n  }\n\n  /**\n     *\n     * @param {string} str\n     * @return {string[]}\n     */\n  split (str) {\n    this.rex.lastIndex = 0;\n    const list = [...str.matchAll(this.rex)];\n\n    // did we parse everything?\n    const eol = list.pop();\n    const last = eol?.index ?? 0;\n\n    if (last !== str.length) {\n      throw new Error('Unknown tokens at pos ' + last + '/' + str.length\n                + ' starting with ' + str.substring(last));\n    }\n\n    // skip whitespace\n    return list.filter(x => x[1] === undefined).map(x => x[0]);\n  }\n}\n\nconst tokRestrict = new Tokenizer('[-=+]', '[A-Z]', '\\\\b[a-z_][a-z_0-9]*\\\\b');\nfunction restrict (set, spec) {\n  if (!spec)\n    return set;\n  let out = new Set([...set]);\n  let mode = 0;\n  const act = [\n    sym => { out = new Set([sym]); mode = 1; },\n    sym => { out.add(sym); },\n    sym => { out.delete(sym); },\n  ];\n  for (const sym of tokRestrict.split(spec)) {\n    if (sym === '=')\n      mode = 0;\n    else if (sym === '+')\n      mode = +1;\n    else if (sym === '-')\n      mode = 2;\n    else\n      act[mode](sym);\n  }\n  return out;\n}\n\nfunction missingIndices (arr, set) {\n  const out = new Set();\n  for (let n = 0; n < arr.length; n++) {\n    if (!set.has(arr[n]))\n      out.add(n);\n  }\n  return out;\n}\n\nfunction isSubset (a, b) {\n  for (const x of a) {\n    if (!b.has(x))\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = { Tokenizer, restrict, missingIndices, isSubset };\n\n\n//# sourceURL=webpack://ski-interpreter/./lib/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;