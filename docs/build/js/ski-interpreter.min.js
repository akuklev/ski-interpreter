(()=>{var t={10:(t,e,s)=>{const r=s(755),n=s(76);t.exports={...r,...n},"undefined"!=typeof window&&(window.SKI=r.SKI,window.SKI.Quest=n.Quest)},695:(t,e,s)=>{const{missingIndices:r,isSubset:n}=s(502),i={terse:!1,max:1e3,maxArgs:32};class a{constructor(){if(new.target===a)throw new Error("Attempt to instantiate abstract class Expr");this.arity=1/0}postParse(){return this}apply(...t){return t.length>0?new c(this,...t):this}expand(){return this}freeVars(){const t=this.getSymbols(),e=new Set;for(const[s,r]of t)s instanceof w&&e.add(s);return e}hasLambda(){return this.getSymbols().has(a.lambdaPlaceholder)}getSymbols(){return new Map([[this,1]])}weight(){return 1}guessArity(t={}){const e=t.max??i.max,s=t.maxArgs??i.maxArgs;let a=this;const o=[];for(let t=0;t<s;t++){const s=a.run({max:e});if(!s.final)break;if(a=s.expr,!a.wantsArgs()){const e=a.getSymbols(),s=r(o,e),i=n(e.keys(),new Set(o)),h=[...e.entries()].filter((([t,e])=>e>1)),l=i&&0===s.size&&0===h.length;return{arity:t,found:!0,canonical:o.length?new g(o,a):a,proper:i,linear:l,...s.size?{skip:s}:{}}}const i=new w("abcdefgh"[t]??"x"+t);o.push(i),a=a.apply(i)}return{proper:!1,found:!1}}wantsArgs(){return!0}reduce(t){return null}subst(t,e){return null}step(){return{expr:this,steps:0,changed:!1}}run(t={},...e){t instanceof a&&(e.unshift(t),t={});let s=e?this.apply(...e):this,r=t.steps??0;const n=(t.max??i.max)+r;let o=!1;for(;r<n;){const t=s.step();if(!t.changed){o=!0;break}r+=t.steps,s=t.expr}if(t.throw&&!o)throw new Error("Failed to compute expression in "+n+" steps");return{final:o,steps:r,expr:s}}*walk(t={}){const e=t.max??1/0;let s=0,r=this,n=!1;for(;s<e;){const t=r.step();if(t.changed||(n=!0),yield{expr:r,steps:s,final:n},n)break;s+=t.steps,r=t.expr}}equals(t){return this===t}expect(t){if(!(t instanceof a))throw new Error("Attempt to expect a combinator to equal something else: "+t);if(this.equals(t))return;const e=new Error("Found term "+this+" but expected "+t);throw e.expected=t.toString(),e.actual=this.toString(),e}toString(t={}){throw new Error("No toString() method defined in class "+this.constructor.name)}needsParens(){return!1}toJSON(){return this.expand().toString({terse:!1})}}const[o,h,l,p]=function*(){for(let t=0;;yield t++);}(),u=new Set([(h<<4)+h,(h<<4)+l,(l<<4)+h,(l<<4)+l,(l<<4)+p,(p<<4)+h,(o<<4)+h]);class c extends a{constructor(t,...e){super(),this.fun=t,this.args=e,this.final=!1}weight(){return this.args.reduce(((t,e)=>t+e.weight()),this.fun.weight())}getSymbols(){const t=this.fun.getSymbols();for(const e of this.args)for(const[s,r]of e.getSymbols())t.set(s,(t.get(s)??0)+r);return t}wantsArgs(){return this.fun.wantsArgs()}apply(...t){return 0===t.length?this:this.fun.apply(...this.args,...t)}expand(){return this.fun.expand().apply(...this.args.map((t=>t.expand())))}subst(t,e){const s=this.fun.subst(t,e);let r=null===s?0:1;const n=[];for(const s of this.args){const i=s.subst(t,e);null===i?n.push(s):(n.push(i),r++)}return r?(s??this.fun).apply(...n):null}step(){if(!this.final){const t=this.fun.reduce(this.args);if(t)return{expr:t,steps:1,changed:!0};const e=this.fun.step();if(e.changed)return{expr:e.expr.apply(...this.args),steps:e.steps,changed:!0};for(let t=0;t<this.args.length;t++){const e=this.args[t].step();if(!e.changed)continue;const s=this.args.slice();return s[t]=e.expr,{expr:this.fun.apply(...s),steps:e.steps,changed:!0}}}return this.final=!0,{expr:this,steps:0,changed:!1}}equals(t){if(!(t instanceof c))return!1;if(t.args.length!==this.args.length)return!1;if(!this.fun.equals(t.fun))return!1;for(let e=0;e<this.args.length;e++)if(!this.args[e].equals(t.args[e]))return!1;return!0}toString(t={}){if(t.terse??i.terse){const e=[];let s=0;for(const r of[this.fun,...this.args]){let n=r.toString(t),i=o;n.match(/^[A-Z]$/)?i=l:n.match(/^[a-z][a-z_0-9]*$/)?i=p:n.match(/^[0-9]+$/)||(0!==e.length||r.needsParens())&&(n="("+n+")",i=h),!u.has(s<<4|i)&&e.length>0&&e.push(" "),e.push(n),s=i}return e.join("")}return(this.fun.needsParens()?"("+this.fun+")":this.fun+"")+this.args.map((t=>"("+t+")")).join("")}}class m extends a{constructor(t){if(super(),"string"!=typeof t||0===t.length)throw new Error("Attempt to create a named term with improper name");this.name=t}toString(){return this.name}}let d=0;class w extends m{constructor(t){super(t),this.id=++d}subst(t,e){return this===t?e:null}weight(){return 0}wantsArgs(){return!1}}class f extends m{constructor(t,e,s,r={}){super(t),this.arity=e,this.impl=s,void 0!==r.skip&&(this.skip=new Set(r.skip)),void 0!==r.note&&(this.note=r.note),r.apply&&(this.onApply=r.apply)}apply(...t){if(this.onApply&&t.length>=1){const e=this.onApply(t[0]);if(e instanceof a)return e.apply(...t.slice(1))}return super.apply(...t)}reduce(t){return t.length<this.arity?null:this.impl(...t.slice(0,this.arity)).apply(...t.slice(this.arity))}toJSON(){return"Native:"+this.name}}class g extends a{constructor(t,e){if(Array.isArray(t)){if(0===t.length)throw new Error("empty argument list in lambda constructor");const[s,...r]=t,n=new Set([s.name]);for(;r.length>0;){const t=r.pop();if(n.has(t.name))throw new Error("Duplicate free var name "+t+" in lambda expression");n.add(t.name),e=new g(t,e)}t=s}super();const s=new w(t.name);this.arg=s,this.impl=e.subst(t,s)??e,this.arity=1}getSymbols(){const t=this.impl.getSymbols();return t.delete(this.arg),t.set(a.lambdaPlaceholder,(t.get(a.lambdaPlaceholder)??0)+1),t}weight(){return this.impl.weight()+1}reduce(t){if(0===t.length)return null;const[e,...s]=t;return(this.impl.subst(this.arg,e)??this.impl).apply(...s)}subst(t,e){if(t===this.arg)return null;const s=this.impl.subst(t,e);return s?new g(this.arg,s):null}expand(){return new g(this.arg,this.impl.expand())}equals(t){if(!(t instanceof g))return!1;const e=new w("t");return t.reduce([e]).equals(this.reduce([e]))}toString(t={}){return this.arg+"->"+this.impl.toString(t)}needsParens(){return!0}}class x extends f{constructor(t){const e=Number.parseInt(t);if(!(e>=0))throw new Error("Church number must be a nonnegative integer");super(""+e,2,(function(t,s){let r=s;for(let s=e;s-- >0;)r=t.apply(r);return r})),this.n=e,this.arity=2}equals(t){return t instanceof x&&this.n===t.n}}a.lambdaPlaceholder=new f("->",1,(t=>t),{note:"Lambda placeholder",apply:t=>{throw new Error("Attempt to use a placeholder in expression")}}),t.exports={Expr:a,App:c,FreeVar:w,Lambda:g,Native:f,Alias:class extends m{constructor(t,e,s={}){super(t),this.impl=e,s.note&&(this.note=s.note);const r=s.canonize?e.guessArity({max:s.max,maxArgs:s.maxArgs}):{found:!1};this.arity=r.found&&r.proper&&r.arity||0,this.skip=r.skip,this.proper=r.proper??!1,this.terminal=s.terminal??this.proper,this.canonical=r.canonical}getSymbols(){return this.terminal?new Map([[this,1]]):this.impl.getSymbols()}weight(){return this.terminal?1:this.impl.weight()}expand(){return this.impl.expand()}subst(t,e){return this.impl.subst(t,e)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}reduce(t){return t.length<this.arity?null:this.impl.apply(...t)}wantsArgs(){return this.impl.wantsArgs()}equals(t){return t.equals(this.impl)}toString(t){return this.outdated?this.impl.toString(t):super.toString(t)}needsParens(){return!!this.outdated&&this.impl.needsParens()}},Church:x,globalOptions:i}},755:(t,e,s)=>{const{Tokenizer:r,restrict:n}=s(502),{globalOptions:i,Expr:a,App:o,FreeVar:h,Lambda:l,Native:p,Alias:u,Church:c}=s(695);class m extends a{apply(...t){return t.length?t.shift().apply(...t):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}}class d extends m{constructor(t,e={}){if(super(),this.impl=new m,t instanceof h)this.terms=[t];else{if(!(t instanceof d))throw new Error("Expected FreeVar or PartialLambda");if(!(t.impl instanceof h))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...t.terms,t.impl]}}apply(t,...e){if(null===t||0!==e.length)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(t),this}postParse(){return new l(this.terms,this.impl)}}const w=new r("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+");class f{constructor(t={}){this.annotate=t.annotate??!1,this.known={...g},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known));for(const e in t.terms??{})t.terms[e].match(/^Native:/)||this.add(e,t.terms[e]);this.hasNumbers=t.numbers??!0,this.hasLambdas=t.lambdas??!0,t.allow&&this.restrict(t.allow)}add(t,e,s){if("string"==typeof t)if("string"==typeof e)t=new u(t,this.parse(e),{canonize:!0});else{if(!(e instanceof a))throw new Error("add: term must be an Alias or a string and impl must be an Expr or a string");t=new u(t,e,{canonize:!0})}else t instanceof u&&(t=new u(t.name,t.impl,{canonize:!0}));if(!(t instanceof u))throw new Error("add: term must be an Alias or a string (accompanied with an implementation)");return this.annotate&&void 0===s&&t.canonical&&(s=t.canonical.toString({terse:!0})),void 0!==s&&(t.note=s),this.known[""+t]=t,this.allow.add(""+t),this}maybeAdd(t,e){return this.known[t]?this.allow.add(t):this.add(t,e),this}restrict(t){return this.allow=n(this.allow,t),this}showRestrict(t="+"){const e=[];let s=!0;for(const r of[...n(this.allow,t)].sort()){const t=r.match(/^[A-Z]$/);!e.length||s&&t||e.push(" "),e.push(r),s=t}return e.join("")}remove(t){return this.known[t].outdated=!0,delete this.known[t],this.allow.delete(t),this}getTerms(){const t={};for(const e of Object.keys(this.known))this.allow.has(e)&&(t[e]=this.known[e]);return t}parse(t,e={},s={}){const r=t.replace(/\/\/[^\n]*$/gm,"").split(/\s*;[\s;]*/).filter((t=>t.match(/\S/))),n={...e};let i=new m;for(const t of r){const[e,r,a]=t.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(i instanceof u&&(i.outdated=!0),i=this.parseLine(a,n,s),void 0!==r){if(void 0!==n[r])throw new Error("Attempt to redefine a known term: "+r);i=new u(r,i),n[r]=i}}for(const t in n)!e[t]&&n[t]instanceof f.classes.FreeVar&&(e[t]=n[t]);return i}parseLine(t,e={},s={}){const r={numbers:s.numbers??this.hasNumbers,lambdas:s.lambdas??this.hasLambdas,allow:n(this.allow,s.allow)};r.numbers?r.allow.add("+"):r.allow.delete("+");const i=w.split(t),a=new m,o=[a];for(const s of i)if("("===s)o.push(a);else if(")"===s){if(o.length<2)throw new Error("unbalanced input: extra closing parenthesis"+t);const e=o.pop().postParse(),s=o.pop();o.push(s.apply(e))}else if("->"===s){if(!r.lambdas)throw new Error("Lambdas not supported, allow them explicitly");o.push(new d(o.pop(),e))}else if(s.match(/^[0-9]+$/)){if(!r.numbers)throw new Error("Church numbers not supported, allow them explicitly");const t=o.pop();o.push(t.apply(new c(s)))}else{const t=o.pop();if(!e[s]&&this.known[s]&&!r.allow.has(s))throw new Error("Term '"+s+"' is not in the restricted set "+[...r.allow].sort().join(" "));const n=e[s]??this.known[s]??(e[s]=new h(s));o.push(t.apply(n))}if(1!==o.length)throw new Error("unbalanced input: missing "+(o.length-1)+" closing parenthesis:"+t);return o.pop().postParse()}toJSON(){return{allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,terms:this.getTerms(),annotate:this.annotate}}}f.free=(...t)=>t.map((t=>new h(t))),f.church=t=>new c(t),f.classes={Expr:a,Native:p,Alias:u,FreeVar:h,Lambda:l,Church:c};const g={I:new p("I",1,(t=>t),{note:"x -> x"}),K:new p("K",2,((t,e)=>t),{skip:[1],note:"x -> y -> x"}),S:new p("S",3,((t,e,s)=>t.apply(s,e.apply(s))),{note:"x -> y -> z -> x z (y z)"}),B:new p("B",3,((t,e,s)=>t.apply(e.apply(s))),{note:"x -> y -> z -> x (y z)"}),C:new p("C",3,((t,e,s)=>t.apply(s).apply(e)),{note:"x -> y -> z -> x z y"}),W:new p("W",2,((t,e)=>t.apply(e).apply(e)),{note:"x -> y -> x y y"}),"+":new p("+",3,((t,e,s)=>e.apply(t.apply(e,s))),{note:"n->n+1 or SB",apply:t=>t instanceof c?new c(t.n+1):null})};for(const t in g)f[t]=g[t];f.native=g,f.options=i,f.lambdaPlaceholder=a.lambdaPlaceholder,t.exports={SKI:f}},76:(t,e,s)=>{const{SKI:r}=s(755),{Expr:n,FreeVar:i,Alias:a,Lambda:o}=r.classes;class h{constructor(t,e,s={},n={},i=new r){if(2!==e.length)throw new Error("Case accepts exactly 2 strings");this.max=s.max??1e3,this.note=s.note,n={...n},[this.e1,this.e2]=e.map((e=>new o(t,i.parse(e,n))))}check(...t){const e=(t,e)=>t.reduce(e)??t.apply(...e),s=e(this.e1,t),r=s.run({max:this.max}),n=e(this.e2,t).expand().run({max:this.max});let i=null;return r.final&&n.final?r.expr.equals(n.expr)||(i="expected: "+n.expr):i="failed to reach normal form in "+this.max+" steps",{pass:!i,reason:i,steps:r.steps,start:s,found:r.expr,expected:n.expr,note:this.note,args:t,case:this}}}t.exports={Quest:class{constructor(t={}){const{input:e,vars:s,cases:n,allow:i,numbers:o,lambdas:h,subst:l,engine:p,engineFull:u,...c}=t;this.engine=p??new r,this.engineFull=u??new r,this.restrict={allow:i,numbers:o??!1,lambdas:h??!1},this.vars={},this.subst=Array.isArray(l)?l:[l??"phi"];for(const t of s??[]){const e=this.engineFull.parse(t,this.vars);e instanceof r.classes.Alias&&(this.vars[e.name]=new a(e.name,e.impl,{terminal:!0,canonize:!1}))}if(this.input=r.free(...Array.isArray(e)?e:[e]),0===e.length)throw new Error("input parameter must be string or string[]");this.varsFull={...this.vars};for(const t of this.input){if(t.name in this.varsFull)throw new Error("input placeholder name is duplicated or clashes with vars: "+t.name);this.varsFull[t.name]=t}var m;this.cases=[],this.title=c.title,c.descr=void 0===(m=c.descr)?m:Array.isArray(m)?m.join(" "):""+m,this.descr=c.descr,this.meta=c;for(const t of n??[])this.add(...t)}allowed(){const t=this.restrict.allow??"",e=Object.keys(this.vars).sort();return t?this.engine.showRestrict(t+"+"+e.join(" ")):e.map((t=>"+"+t)).join(" ")}add(t,...e){return"string"==typeof t&&(e.unshift(t),t={}),this.cases.push(new h(this.input,e,t,this.varsFull,this.engineFull)),this}check(...t){try{if(t.length!==this.input.length)throw new Error("Solutions provided "+t.length+" terms where "+this.input.length+" are expected");const e=t.map((t=>"string"==typeof t?this.engine.parse(t,this.vars,this.restrict):t)).map(((t,e)=>new a(this.subst[e]??this.input[e],t))),s=this.cases.map((t=>t.check(...e))),r=s.reduce(((t,e)=>t&&e.pass),!0),n=s.reduce(((t,e)=>t+e.steps),0);return{expr:e[0],input:e,pass:r,steps:n,details:s}}catch(t){return{pass:!1,details:[],exception:t}}}show(){return[...this.cases]}}}},502:t=>{class e{constructor(...t){const e="$|(\\s+)|"+t.map((t=>"(?:"+t+")")).sort(((t,e)=>e.length-t.length)).join("|");this.rex=new RegExp(e,"gys")}split(t){this.rex.lastIndex=0;const e=[...t.matchAll(this.rex)],s=e.pop()?.index??0;if(s!==t.length)throw new Error("Unknown tokens at pos "+s+"/"+t.length+" starting with "+t.substring(s));return e.filter((t=>void 0===t[1])).map((t=>t[0]))}}const s=new e("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");t.exports={Tokenizer:e,restrict:function(t,e){if(!e)return t;let r=new Set([...t]),n=0;const i=[t=>{r=new Set([t]),n=1},t=>{r.add(t)},t=>{r.delete(t)}];for(const t of s.split(e))"="===t?n=0:"+"===t?n=1:"-"===t?n=2:i[n](t);return r},missingIndices:function(t,e){const s=new Set;for(let r=0;r<t.length;r++)e.has(t[r])||s.add(r);return s},isSubset:function(t,e){for(const s of t)if(!e.has(s))return!1;return!0}}}},e={};!function s(r){var n=e[r];if(void 0!==n)return n.exports;var i=e[r]={exports:{}};return t[r](i,i.exports,s),i.exports}(10)})();