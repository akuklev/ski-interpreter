(()=>{var t={10:(t,e,s)=>{const r=s(755),n=s(76);t.exports={...r,...n},"undefined"!=typeof window&&(window.SKI=r.SKI,window.SKI.Quest=n.Quest)},695:(t,e,s)=>{"use strict";const{skipDup:r,isSubset:n}=s(502),i={terse:!0,max:1e3,maxArgs:32};class a{constructor(){if(new.target===a)throw new Error("Attempt to instantiate abstract class Expr")}postParse(){return this}apply(...t){return t.length>0?new o(this,...t):this}expand(){return this}freeVars(){const t=this.getSymbols(),e=new Set;for(const[s,r]of t)s instanceof l&&e.add(s);return e}hasLambda(){return this.getSymbols().has(a.lambdaPlaceholder)}freeOnly(){for(const[t,e]of this.getSymbols())if(!(t instanceof l))return!1;return!0}getSymbols(){return new Map([[this,1]])}replace(t,e={}){const s=[];if(0===t.length)return this;for(const r of t){const t=Array.isArray(r)?r:[r,r];if(t[0]=t[0].guess(e).expr,!t[0])throw new Error("Failed to canonize term "+r);if(2!==t.length)throw new Error("Expected a pair of terms to replace, got "+r);s.push(t)}return this._replace(s,e)??this}_replace(t,e){const s=this.guess(e).expr;for(const[e,r]of t)if(s.equals(e))return r;return null}weight(){return 1}guess(t={}){const e=t.max??i.max,s=t.maxArgs??i.maxArgs;return this._guess({max:e,maxArgs:s,index:0})}_guess(t,e=[],s=0){if(e.length>t.maxArgs||s>t.max)return{grounded:!1,steps:s};if(this.freeOnly())return{grounded:!0,steps:s,...w(e,this)};const r=this.run({max:(t.max-s)/3});if(s+=r.steps,!r.final)return{grounded:!1,steps:s};if(0!==r.steps)return r.expr._guess(t,e,s);if(this._firstVar())return{grounded:!1,steps:s};const n=b(e.length+t.index);return this.apply(n)._guess(t,[...e,n],s)}_firstVar(){return!1}*lambdify(t={}){const e=x(this);yield*y(e,t)}*rewriteSKI(t={}){let e=0,s=this;for(;;){const r={max:t.max??1,steps:0},n=s._rski(r),i=0===r.steps;if(yield{expr:s,steps:e,final:i},i)break;s=n,e+=r.steps}}renameVars(t){return this}_rski(t){return this}reduce(t){return null}subst(t,e){return null}step(){return{expr:this,steps:0,changed:!1}}run(t={},...e){t instanceof a&&(e.unshift(t),t={});let s=e?this.apply(...e):this,r=t.steps??0;const n=Math.max(t.max??i.max,1)+r;let o=!1;for(;r<n;){const t=s.step();if(!t.changed){o=!0;break}r+=t.steps,s=t.expr}if(t.throw&&!o)throw new Error("Failed to compute expression in "+n+" steps");return{final:o,steps:r,expr:s}}*walk(t={}){const e=t.max??1/0;let s=0,r=this,n=!1;for(;s<e;){const t=r.step();if(t.changed||(n=!0),yield{expr:r,steps:s,final:n},n)break;s+=t.steps,r=t.expr}}equals(t){return this===t}contains(t){return this===t||this.equals(t)}expect(t,e=""){if(e=e?e+": ":"",!(t instanceof a))throw new Error(e+"attempt to expect a combinator to equal something else: "+t);if(this.equals(t))return;const s=new Error(e+"found term "+this+" but expected "+t);throw s.expected=t.toString(),s.actual=this.toString(),s}toString(t={}){throw new Error("No toString() method defined in class "+this.constructor.name)}needsParens(t){return!1}toJSON(){return this.expand().toString({terse:!1})}}class o extends a{constructor(t,...e){if(0===e.length)throw new Error("Attempt to create an application with no arguments (likely interpreter bug)");super(),this.arg=e.pop(),this.fun=e.length?new o(t,...e):t,this.final=!1,this.arity=this.fun.arity>0?this.fun.arity-1:0}weight(){return this.fun.weight()+this.arg.weight()}getSymbols(){const t=this.fun.getSymbols();for(const[e,s]of this.arg.getSymbols())t.set(e,(t.get(e)??0)+s);return t}_guess(t,e=[],s=0){if(e.length>t.maxArgs||s>t.max)return{grounded:!1,steps:s};const r=super._guess(t,e,s);if(r.grounded)return r;s=r.steps;const[n,i]=this.split().map((s=>s._guess({...t,maxArgs:.8*t.maxArgs-2,max:.8*t.max-10,index:e.length+t.index})));s+=n.steps+i.steps;const a=n.expr&&i.expr&&n.expr.apply(i.expr);if(a&&n.grounded&&i.grounded&&this._firstVar())return{grounded:!0,steps:s,...w(e,a,{discard:n.discard||i.discard,duplicate:n.duplicate||i.duplicate})};const o=r.expr?.weight()??1/0;return a&&a.weight()<o?{grounded:!1,steps:s,...w(e,a,{synth:!0,discard:n.discard||i.discard,duplicate:n.duplicate||i.duplicate})}:r}_firstVar(){return this.fun._firstVar()}apply(...t){return 0===t.length?this:new o(this,...t)}expand(){return this.fun.expand().apply(this.arg.expand())}_replace(t,e){const s=super._replace(t,e);if(s)return s;const[r,n]=this.split();return(r._replace(t,e)??r).apply(n._replace(t,e)??n)}renameVars(t){return this.fun.renameVars(t).apply(this.arg.renameVars(t))}subst(t,e){const s=this.fun.subst(t,e),r=this.arg.subst(t,e);return s||r?(s??this.fun).apply(r??this.arg):null}step(){if(!this.final){if(0===this.arity){const t=this.fun.reduce([this.arg]);if(t)return{expr:t,steps:1,changed:!0}}const t=this.fun.step();if(t.changed)return{expr:t.expr.apply(this.arg),steps:t.steps,changed:!0};const e=this.arg.step();if(e.changed)return{expr:this.fun.apply(e.expr),steps:e.steps,changed:!0};this.final=!0}return{expr:this,steps:0,changed:!1}}reduce(t){return this.fun.reduce([this.arg,...t])}split(){return[this.fun,this.arg]}_rski(t){return t.steps>=t.max?this:this.fun._rski(t).apply(this.arg._rski(t))}equals(t){return t instanceof o&&this.fun.equals(t.fun)&&this.arg.equals(t.arg)}contains(t){return this.fun.contains(t)||this.arg.contains(t)||super.contains(t)}needsParens(t){return!t}toString(t={}){const e=this.fun.toString(t),s=this.fun.needsParens(!0)?"("+e+")":e;if(t.terse??i.terse){let e=this.arg.toString(t);this.arg.needsParens(!1)&&(e="("+e+")");const r=s.match(/\)$/)||e.match(/^\(/)||s.match(/[A-Z]$/)&&e.match(/^[a-z]/i)?"":" ";return s+r+e}return s+"("+this.arg.toString(t)+")"}}class p extends a{constructor(t){if(super(),"string"!=typeof t||0===t.length)throw new Error("Attempt to create a named term with improper name");this.name=t}toString(){return this.name}}let h=0;class l extends p{constructor(t){super(t),this.id=++h}subst(t,e){return this===t?e:null}weight(){return 0}_firstVar(){return!0}toString(t={}){return t.html&&/^[a-z]$/.test(this.name)?"<var>"+this.name+"</var>":this.name}}class c extends p{constructor(t,e,s={}){super(t),this.impl=e,s.apply&&(this.onApply=s.apply),this.arity=s.arity??1;const r=s.canonize??1?this.guess():{grounded:!1};s.arity||(this.arity=r.arity||1),this.note=s.note??r.expr?.toString({terse:!0,html:!0})}apply(...t){if(this.onApply&&t.length>=1){if("function"!=typeof this.onApply)throw new Error("Native combinator "+this+" has an invalid onApply property  of type"+typeof this.onApply+": "+this.onApply);const e=this.onApply(t[0]);if(e instanceof a)return e.apply(...t.slice(1))}return super.apply(...t)}_rski(t){if(this===u.I||this===u.K||this===u.S||t.steps>=t.max)return this;const e=this.guess().expr;return e?(t.steps++,e._rski(t)):this}reduce(t){if(t.length<this.arity)return null;let e=0,s=this.impl;for(;"function"==typeof s;){if(e>=t.length)return null;s=s(t[e++])}if(!(s instanceof a))throw new Error("Native combinator "+this+" reduced to a non-expression: "+s);return s.apply(...t.slice(e))}toJSON(){return"Native:"+this.name}}const u={};function d(t,e,s){u[t]=new c(t,e,s)}class m extends a{constructor(t,e){if(Array.isArray(t)){if(0===t.length)throw new Error("empty argument list in lambda constructor");const[s,...r]=t,n=new Set([s.name]);for(;r.length>0;){const t=r.pop();if(n.has(t.name))throw new Error("Duplicate free var name "+t+" in lambda expression");n.add(t.name),e=new m(t,e)}t=s}super();const s=new l(t.name);this.arg=s,this.impl=e.subst(t,s)??e,this.arity=1}getSymbols(){const t=this.impl.getSymbols();return t.delete(this.arg),t.set(a.lambdaPlaceholder,(t.get(a.lambdaPlaceholder)??0)+1),t}weight(){return this.impl.weight()+1}_guess(t,e=[],s=0){if(e.length>t.maxArgs)return{grounded:!1,steps:s};const r=b(e.length+t.index);return this.reduce([r])._guess(t,[...e,r],s+1)}reduce(t){if(0===t.length)return null;const[e,...s]=t;return(this.impl.subst(this.arg,e)??this.impl).apply(...s)}subst(t,e){if(t===this.arg)return null;const s=this.impl.subst(t,e);return s?new m(this.arg,s):null}expand(){return new m(this.arg,this.impl.expand())}renameVars(t){const e=new l(t.next().value),s=this.impl.subst(this.arg,e)??this.impl;return new m(e,s.renameVars(t))}_rski(t){const e=this.impl._rski(t);if(t.steps>=t.max)return new m(this.arg,e);if(t.steps++,e===this.arg)return u.I;if(!e.getSymbols().has(this.arg))return u.K.apply(e);if(e instanceof o){const[s,r]=e.split();return r!==this.arg||s.getSymbols().has(this.arg)?u.S.apply(new m(this.arg,s)._rski(t),new m(this.arg,r)._rski(t)):s._rski(t)}throw new Error("Don't know how to convert to SKI"+this)}_replace(t,e){return super._replace(t,e)||new m(this.arg,this.impl._replace(t,e)??this.impl)}equals(t){if(!(t instanceof m))return!1;const e=new l("t");return t.reduce([e]).equals(this.reduce([e]))}contains(t){return this.equals(t)||this.impl.contains(t)}toString(t={}){const e=t.html?" &mapsto; ":"->";return this.arg.toString(t)+e+this.impl.toString(t)}needsParens(t){return!0}}class f extends c{constructor(t){const e=Number.parseInt(t);if(!(e>=0))throw new Error("Church number must be a non-negative integer");const s=""+e;super(s,(t=>s=>{let r=s;for(let s=e;s-- >0;)r=t.apply(r);return r}),{arity:2,canonize:!1,note:s}),this.n=e,this.arity=2}equals(t){return t instanceof f&&this.n===t.n}}class g extends p{constructor(t,e,s={}){super(t),this.impl=e,s.note&&(this.note=s.note);const r=s.canonize?e.guess({max:s.max,maxArgs:s.maxArgs}):{grounded:!1};this.arity=r.proper&&r.arity||0,this.proper=r.proper??!1,this.terminal=s.terminal??this.proper,this.canonical=r.expr}getSymbols(){return this.terminal?new Map([[this,1]]):this.impl.getSymbols()}weight(){return this.terminal?1:this.impl.weight()}expand(){return this.impl.expand()}subst(t,e){return this.impl.subst(t,e)}_guess(t,e=[],s=0){return this.impl._guess(t,e,s)}step(){return this.arity>0?{expr:this,steps:0,changed:!1}:{expr:this.impl,steps:0,changed:!0}}reduce(t){return t.length<this.arity?null:this.impl.apply(...t)}_firstVar(){return this.impl._firstVar()}equals(t){return t.equals(this.impl)}contains(t){return this.impl.contains(t)}_rski(t){return this.impl._rski(t)}toString(t){return this.outdated?this.impl.toString(t):super.toString(t)}needsParens(t){return!!this.outdated&&this.impl.needsParens()}}function w(t,e,s={}){const i=e.getSymbols(),[a,o]=r(t,i);return{expr:t.length?new m(t,e):e,...s.synth?{}:{arity:t.length},...a.size?{skip:a}:{},...o.size?{dup:o}:{},duplicate:!!o.size||s.duplicate||!1,discard:!!a.size||s.discard||!1,proper:n(i.keys(),new Set(t))}}function x(t){if(t instanceof o)return x(t.fun).apply(x(t.arg));if(t instanceof m)return new m(t.arg,x(t.impl));if(t instanceof g)return x(t.impl);const e=t.guess();if(e.expr)return e.expr;throw new Error("Failed to canonize expression: "+t)}function*y(t,e={},s=1/0){if(t.freeOnly())return void(t.weight()<s&&(yield{expr:t,steps:0,comment:"only free vars"}));let r=0,n=0;if(t instanceof o){const[i,a]=t.split();for(const t of y(i,e,s-1)){const e=t.expr.apply(a);r=n+t.steps,e.weight()<s&&(s=e.weight(),yield{expr:e,steps:t.steps,comment:t.comment+"(app)"})}n=r;for(const t of y(a,e,s-1)){const e=i.apply(t.expr);r=n+t.steps,e.weight()<s&&(s=e.weight(),yield{expr:e,steps:t.steps,comment:t.comment+"(app)"})}n=r}if(t instanceof m){for(const i of y(t.impl,e,s-1)){const e=new m(t.arg,i.expr);e.weight()<s&&(s=e.weight(),r=n+i.steps,yield{expr:e,steps:i.steps,comment:i.comment+"(lambda)"})}n=r}const i=t.guess({max:e.max,maxArgs:e.maxArgs});i.expr&&i.expr.weight()<s&&(yield{expr:i.expr,steps:n+i.steps,comment:"canonical"})}function b(t){return new l("abcdefgh"[t]??"x"+t)}d("I",(t=>t)),d("K",(t=>e=>t)),d("S",(t=>e=>s=>t.apply(s,e.apply(s)))),d("B",(t=>e=>s=>t.apply(e.apply(s)))),d("C",(t=>e=>s=>t.apply(s).apply(e))),d("W",(t=>e=>t.apply(e).apply(e))),d("+",(t=>e=>s=>e.apply(t.apply(e,s))),{note:"<var>n</var> &mapsto; <var>n</var> + 1 <i>or</i> SB",apply:t=>t instanceof f?new f(t.n+1):null}),a.lambdaPlaceholder=new c("->",(t=>t),{arity:1,canonize:!1,note:"Lambda placeholder",apply:t=>{throw new Error("Attempt to use a placeholder in expression")}}),t.exports={Expr:a,App:o,FreeVar:l,Lambda:m,Native:c,Alias:g,Church:f,globalOptions:i,native:u}},755:(t,e,s)=>{const{Tokenizer:r,restrict:n}=s(502),{globalOptions:i,Expr:a,App:o,FreeVar:p,Lambda:h,Native:l,Alias:c,Church:u,native:d}=s(695);class m extends a{apply(...t){return t.length?t.shift().apply(...t):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}}class f extends m{constructor(t,e={}){if(super(),this.impl=new m,t instanceof p)this.terms=[t];else{if(!(t instanceof f))throw new Error("Expected FreeVar or PartialLambda");if(!(t.impl instanceof p))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...t.terms,t.impl]}}apply(t,...e){if(null===t||0!==e.length)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(t),this}postParse(){return new h(this.terms,this.impl)}}const g=new r("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->","\\+");class w{constructor(t={}){this.annotate=t.annotate??!1,this.known={...d},this.hasNumbers=!0,this.hasLambdas=!0,this.allow=new Set(Object.keys(this.known));for(const e in t.terms??{})t.terms[e].match(/^Native:/)||this.add(e,t.terms[e]);this.hasNumbers=t.numbers??!0,this.hasLambdas=t.lambdas??!0,t.allow&&this.restrict(t.allow)}add(t,e,s){if("string"==typeof t)if("string"==typeof e)t=new c(t,this.parse(e),{canonize:!0});else{if(!(e instanceof a))throw new Error("add: term must be an Alias or a string and impl must be an Expr or a string");t=new c(t,e,{canonize:!0})}else t instanceof c&&(t=new c(t.name,t.impl,{canonize:!0}));if(!(t instanceof c))throw new Error("add: term must be an Alias or a string (accompanied with an implementation)");return this.annotate&&void 0===s&&t.canonical&&(s=t.canonical.toString({terse:!0,html:!0})),void 0!==s&&(t.note=s),this.known[""+t]=t,this.allow.add(""+t),this}maybeAdd(t,e){return this.known[t]?this.allow.add(t):this.add(t,e),this}restrict(t){return this.allow=n(this.allow,t),this}showRestrict(t="+"){const e=[];let s=!0;for(const r of[...n(this.allow,t)].sort()){const t=r.match(/^[A-Z]$/);!e.length||s&&t||e.push(" "),e.push(r),s=t}return e.join("")}remove(t){return this.known[t].outdated=!0,delete this.known[t],this.allow.delete(t),this}getTerms(){const t={};for(const e of Object.keys(this.known))this.allow.has(e)&&(t[e]=this.known[e]);return t}parse(t,e={},s={}){if("string"!=typeof t)throw new Error("parse: source must be a string, got "+typeof t);const r=t.replace(/\/\/[^\n]*$/gm,"").split(/\s*;[\s;]*/).filter((t=>t.match(/\S/))),n={...e};let i=new m;for(const t of r){const[e,r,a]=t.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(i instanceof c&&(i.outdated=!0),i=this.parseLine(a,n,s),void 0!==r){if(void 0!==n[r])throw new Error("Attempt to redefine a known term: "+r);i=new c(r,i),n[r]=i}}for(const t in n)!e[t]&&n[t]instanceof w.classes.FreeVar&&(e[t]=n[t]);return i}parseLine(t,e={},s={}){const r={numbers:s.numbers??this.hasNumbers,lambdas:s.lambdas??this.hasLambdas,allow:n(this.allow,s.allow)};r.numbers?r.allow.add("+"):r.allow.delete("+");const i=g.split(t),a=new m,o=[a];for(const s of i)if("("===s)o.push(a);else if(")"===s){if(o.length<2)throw new Error("unbalanced input: extra closing parenthesis"+t);const e=o.pop().postParse(),s=o.pop();o.push(s.apply(e))}else if("->"===s){if(!r.lambdas)throw new Error("Lambdas not supported, allow them explicitly");o.push(new f(o.pop(),e))}else if(s.match(/^[0-9]+$/)){if(!r.numbers)throw new Error("Church numbers not supported, allow them explicitly");const t=o.pop();o.push(t.apply(new u(s)))}else{const t=o.pop();if(!e[s]&&this.known[s]&&!r.allow.has(s))throw new Error("Term '"+s+"' is not in the restricted set "+[...r.allow].sort().join(" "));const n=e[s]??this.known[s]??(e[s]=new p(s));o.push(t.apply(n))}if(1!==o.length)throw new Error("unbalanced input: missing "+(o.length-1)+" closing parenthesis:"+t);return o.pop().postParse()}toJSON(){return{allow:this.showRestrict("+"),numbers:this.hasNumbers,lambdas:this.hasLambdas,terms:this.getTerms(),annotate:this.annotate}}}w.free=(...t)=>t.map((t=>new p(t))),w.church=t=>new u(t),w.classes={Expr:a,Native:l,Alias:c,FreeVar:p,Lambda:h,Church:u};for(const t in d)w[t]=d[t];w.native=d,w.options=i,w.lambdaPlaceholder=a.lambdaPlaceholder,t.exports={SKI:w}},76:(t,e,s)=>{const{SKI:r}=s(755),{Expr:n,FreeVar:i,Alias:a,Lambda:o}=r.classes;class p{constructor(t,e){this.max=e.max??1e3,this.note=e.note,this.vars={...e.vars??{}},this.input=t,this.engine=e.engine}parse(t){return new o(this.input,this.engine.parse(t,this.vars))}check(...t){throw new Error("not implemented")}}class h extends p{constructor(t,e,s){if(2!==s.length)throw new Error("Case accepts exactly 2 strings");super(t,e),[this.e1,this.e2]=s.map((t=>this.parse(t)))}check(...t){const e=(t,e)=>t.reduce(e)??t.apply(...e),s=e(this.e1,t),r=s.run({max:this.max}),n=e(this.e2,t).run({max:this.max});let i=null;return r.final&&n.final?r.expr.equals(n.expr)||(i="expected: "+n.expr):i="failed to reach normal form in "+this.max+" steps",{pass:!i,reason:i,steps:r.steps,start:s,found:r.expr,expected:n.expr,note:this.note,args:t,case:this}}}const l={grounded:!0,proper:!0,discard:!0,duplicate:!0,linear:!0,affine:!0,arity:!0};class c extends p{constructor(t,e,s){if(super(t,e),s.length>1)throw new Error("PropertyCase accepts exactly 1 string");if(!e.caps||"object"!=typeof e.caps||!Object.keys(e.caps).length)throw new Error("PropertyCase requires a caps object with at least one capability");const r=Object.keys(e.caps).filter((t=>!l[t]));if(r.length)throw new Error("PropertyCase: don't know how to test these capabilities: "+r.join(", "));this.expr=this.parse(s[0]),this.caps=e.caps,this.caps.linear&&(delete this.caps.linear,this.caps.duplicate=!1,this.caps.discard=!1,this.caps.grounded=!0),this.caps.affine&&(delete this.caps.affine,this.caps.grounded=!0,this.caps.duplicate=!1)}check(...t){const e=this.expr.apply(...t),s=e.run({max:this.max}),r=s.expr.guess({max:this.max}),n=[];for(const t in this.caps)r[t]!==this.caps[t]&&n.push("expected property "+t+" to be "+this.caps[t]+", found "+r[t]);return{pass:!n.length,reason:n?n.join("\n"):null,steps:s.steps,start:e,found:s.expr,case:this,note:this.note,args:t}}}t.exports={Quest:class{constructor(t={}){const{input:e,vars:s,cases:n,allow:i,numbers:o,lambdas:p,subst:h,engine:l,engineFull:c,...u}=t;this.engine=l??new r,this.engineFull=c??new r,this.restrict={allow:i,numbers:o??!1,lambdas:p??!1},this.vars={},this.subst=Array.isArray(h)?h:[h??"phi"];const d={};for(const t of s??[]){const e=this.engineFull.parse(t,d);if(e instanceof r.classes.Alias)this.vars[e.name]=new a(e.name,e.impl,{terminal:!0,canonize:!1});else{if(!(e instanceof r.classes.FreeVar))throw new Error("Unsupported given variable type: "+t);this.vars[e.name]=e}}this.input=[];for(const t of Array.isArray(e)?e:[e])this.addInput(t);if(!this.input.length)throw new Error("Quest needs at least one input placeholder");h&&(this.input[0].fancy=this.subst[0]),this.varsFull={...this.vars,...d};for(const t of this.input){if(t.name in this.varsFull)throw new Error("input placeholder name is duplicated or clashes with vars: "+t.name);this.varsFull[t.name]=t.placeholder}var m;this.cases=[],this.title=u.title,u.descr=void 0===(m=u.descr)?m:Array.isArray(m)?m.join(" "):""+m,this.descr=u.descr,this.meta=u;for(const t of n??[])this.add(...t)}allowed(){const t=this.restrict.allow??"",e=Object.keys(this.vars).sort();return t?this.engine.showRestrict(t+"+"+e.join(" ")):e.map((t=>"+"+t)).join(" ")}addInput(t){if("object"!=typeof t&&(t={name:t}),"string"!=typeof t.name)throw new Error("quest 'input' field must be a string or a {name: string, ...} object");[t.placeholder]=r.free(t.name),this.input.push(t)}add(t,...e){"string"==typeof t?(e.unshift(t),t={}):t={...t},t.engine=t.engine??this.engineFull,t.vars=t.vars??this.varsFull;const s=this.input.map((t=>t.placeholder));return this.cases.push(t.caps?new c(s,t,e):new h(s,t,e)),this}prepare(...t){if(t.length!==this.input.length)throw new Error("Solutions provided "+t.length+" terms where "+this.input.length+" are expected");let e=0;const s=[],r={...this.vars};for(let n=0;n<t.length;n++){const o=this.input[n],p=this.engine.parse(t[n],r,{allow:o.allow??this.restrict.allow,numbers:o.numbers??this.restrict.numbers,lambdas:o.lambdas??this.restrict.lambdas});e+=p.weight();const h=p instanceof i?p:new a(o.fancy??o.name,p,{terminal:!0,canonize:!1});r[o.name]=h,s.push(h)}return{prepared:s,weight:e}}check(...t){try{const{prepared:e,weight:s}=this.prepare(...t),r=this.cases.map((t=>t.check(...e))),n=r.reduce(((t,e)=>t&&e.pass),!0),i=r.reduce(((t,e)=>t+e.steps),0);return{expr:e[0],input:e,pass:n,steps:i,details:r,weight:s}}catch(e){return{pass:!1,details:[],exception:e,steps:0,input:t}}}show(){return[...this.cases]}}}},502:t=>{class e{constructor(...t){const e="$|(\\s+)|"+t.map((t=>"(?:"+t+")")).sort(((t,e)=>e.length-t.length)).join("|");this.rex=new RegExp(e,"gys")}split(t){this.rex.lastIndex=0;const e=[...t.matchAll(this.rex)],s=e.pop()?.index??0;if(s!==t.length)throw new Error("Unknown tokens at pos "+s+"/"+t.length+" starting with "+t.substring(s));return e.filter((t=>void 0===t[1])).map((t=>t[0]))}}const s=new e("[-=+]","[A-Z]","\\b[a-z_][a-z_0-9]*\\b");t.exports={Tokenizer:e,restrict:function(t,e){if(!e)return t;let r=new Set([...t]),n=0;const i=[t=>{r=new Set([t]),n=1},t=>{r.add(t)},t=>{r.delete(t)}];for(const t of s.split(e))"="===t?n=0:"+"===t?n=1:"-"===t?n=2:i[n](t);return r},skipDup:function(t,e){const s=new Set,r=new Set;for(let n=0;n<t.length;n++){const i=e.get(t[n])??0;i?i>1&&r.add(n):s.add(n)}return[s,r]},isSubset:function(t,e){for(const s of t)if(!e.has(s))return!1;return!0}}}},e={};!function s(r){var n=e[r];if(void 0!==n)return n.exports;var i=e[r]={exports:{}};return t[r](i,i.exports,s),i.exports}(10)})();