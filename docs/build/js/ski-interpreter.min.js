(()=>{var t={10:(t,s,e)=>{const r=e(592),n=e(76);t.exports={...r,...n},"undefined"!=typeof window&&(window.SKI=r.SKI,window.SKI.Quest=n.Quest)},76:(t,s,e)=>{const{SKI:r}=e(592);class n{constructor(t,s,e,r,...n){s={...s},this.expect=t.parse(r,s).run({throw:!0}).result,this.max=e.max,this.note=e.note,this.args=n.map((e=>t.parse(e,s))),this.feedInput=e.feedInput}check(t){const s=this.feedInput?this.expect.run({max:this.max,throw:!0},t).result:this.expect,e=t.run({max:this.max},...this.args);return{pass:e.final&&s.equals(e.result),count:e.steps,found:e.result,expected:s,args:this.args}}}t.exports={Quest:class{constructor(t={}){const{title:s,descr:e,allow:n,numbers:i,vars:a,cases:o,...p}=t;if(this.engine=new r({allow:n,numbers:i}),this.vars={},a)for(const t of a){const s=this.engine.parse(t,this.vars);s instanceof r.classes.Alias&&(this.vars[s.name]=s.impl)}this.cases=[],this.title=s,this.descr=Array.isArray(e)?e.join(" "):e,this.meta=p;for(const t of o??[])this.add(...t)}add(t={},...s){if("string"==typeof t&&(s.unshift(t),t={}),s.length<1)throw new Error("Too little data for a testcase");return this.cases.push(new n(this.engine,this.vars,t,s.shift(),...s)),this}check(t){try{const s="string"==typeof t?this.engine.parse(t,this.vars):t,e=this.cases.map((t=>t.check(s))),r=e.reduce(((t,s)=>t&&s.pass),!0);return{expr:s,pass:r,details:e}}catch(t){return{pass:!1,details:[],exception:t}}}show(){return[...this.cases]}}}},592:t=>{class s{postParse(){return this}apply(...t){return t.length>0?new e(this,...t):this}expand(){return this}reduce(t){return null}subst(t){return null}step(){return null}run(t={},...e){t instanceof s&&(e.unshift(t),t={});let r=e?this.apply(...e):this,n=t.count??0;const i=(t.max??1e3)+n;let a=!1;for(;n<i;n++){const t=r.step();if(!t){a=!0;break}r=t}if(t.throw&&!a)throw new Error("Failed to compute expression in "+i+" steps");return{final:a,steps:n,result:r}}equals(t){return this===t}toString(){throw new Error("toString() undefined for generic AST")}}class e extends s{constructor(t,...s){super(),this.fun=t,this.args=s,this.final=!1}apply(...t){return 0===t.length?this:this.fun.apply(...this.args,...t)}expand(){return this.fun.expand().apply(...this.args.map((t=>t.expand())))}subst(t){const s=this.fun.subst(t);let e=null===s?0:1;const r=[];for(const s of this.args){const n=s.subst(t);null===n?r.push(s):(r.push(n),e++)}return e?(s??this.fun).apply(...r):null}step(){if(this.final)return null;if(this.fun.fast){const t=this.fun.reduce(this.args);if(t)return t}const t=this.fun.step();let s=t?1:0;const e=[];for(const t of this.args){const r=t.step();e.push(r??t),r&&s++}if(s)return(t??this.fun).apply(...e);return this.fun.reduce(this.args)||(this.final=!0,null)}equals(t){if(!(t instanceof e))return!1;if(t.args.length!==this.args.length)return!1;if(!this.fun.equals(t.fun))return!1;for(let s=0;s<this.args.length;s++)if(!this.args[s].equals(t.args[s]))return!1;return!0}toString(){return this.fun.toString()+this.args.map((t=>"("+t+")")).join("")}}class r extends s{constructor(t){if(super(),"string"!=typeof t||0===t.length)throw new Error("Attempt to create a named term with improper name");this.name=t}toString(){return this.name}}class n extends r{subst(t){for(const s of t)if(this===s[0])return s[1];return null}}class i extends s{constructor(t,s){if(super(),0===t.length)throw new Error("empty argument list in lambda");const e=new Set;for(const s of t){if(e.has(s.name))throw new Error("Duplicate free var name "+s+" in lambda expression");e.add(s.name)}const r=t.map((t=>[t,new n(t.name)]));this.impl=s.subst(r)??s,this.args=r.map((t=>t[1]))}reduce(t){if(t.length<this.args.length)return null;const s=this.args.map((s=>[s,t.shift()]));return(this.impl.subst(s)??this.impl).apply(...t)}subst(t){const s=this.impl.subst(t);return s?new i(this.args,s):null}equals(t){if(!(t instanceof i))return!1;if(this.args.length!==t.args.length)return!1;const s=this.args.map(((t,s)=>new n("t"+s)));return t.reduce([...s]).equals(this.reduce([...s]))}toString(){return"("+this.args.join("->")+"->"+this.impl+")"}}class a extends r{constructor(t,s,e,r={}){super(t),this.arity=s,this.impl=e,r.fast&&(this.fast=!0),void 0!==r.note&&(this.note=r.note)}reduce(t){if(t.length<this.arity)return null;const s=t.splice(this.arity);return this.impl(...t).apply(...s)}}class o extends a{constructor(t){const s=Number.parseInt(t);if(!(s>=0))throw new Error("Church number must be a nonnegative integer");super(""+s,2,(function(t,e){let r=e;for(let e=s;e-- >0;)r=t.apply(r);return r}))}}class p extends r{constructor(t,s){super(t),this.impl=s}expand(){return this.impl.expand()}subst(t){return this.impl.subst(t)}step(){return this.impl}equals(t){return t.equals(this.impl)}toString(){return this.outdated?this.impl.toString():super.toString()}}class h extends s{apply(...t){return t.length?t.shift().apply(...t):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}toString(){return"<empty>"}}class u extends h{constructor(t,s={}){if(super(),this.impl=new h,t instanceof n)this.terms=[t];else{if(!(t instanceof u))throw new Error("Expected FreeVar or PartialLambda");if(!(t.impl instanceof n))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...t.terms,t.impl]}}apply(t,...s){if(null===t||0!==s.length)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(t),this}postParse(){return new i(this.terms,this.impl)}toString(){return this.terms.join("->")+"->"+(this.impl??"???")}}const l={I:new a("I",1,(t=>t),{fast:!0,note:"x -> x"}),K:new a("K",2,((t,s)=>t),{fast:!0,note:"(x y) -> x"}),S:new a("S",3,((t,s,e)=>t.apply(e,s.apply(e))),{note:"(x y z) -> x z (y z)"}),B:new a("B",3,((t,s,e)=>t.apply(s.apply(e))),{note:"(x y z) -> x (y z)"}),C:new a("C",3,((t,s,e)=>t.apply(e).apply(s)),{note:"(x y z) -> x z y"}),W:new a("W",2,((t,s)=>t.apply(s).apply(s)),{note:"(x y) -> x y y"})};class c{constructor(t={}){this.known={},this.hasNumbers=!!t.numbers,this.hasLambdas=!!t.lambdas;const s=t.allow??"SKI";for(const t of s.split(""))this.known[t]=l[t]}add(t,e,r){if("string"==typeof e)e=new p(t,this.parseLine(e));else if(Array.isArray(e))e=new a(t,e[0],e[1],e[2]??{});else{if(!(e instanceof s))throw new Error("add: impl must be an Ast, a string, or a [arity, impl] pair");e=new p(t,e)}return void 0!==r&&(e.note=r),this.known[t]=e,this}remove(t){return this.known[t].outdated=!0,delete this.known[t],this}getTerms(){return{...this.known}}parse(t,s={}){const e=t.replace(/\/\/[^\n]*\n/gs,"").split(/\s*;[\s;]*/).filter((t=>t.match(/\S/))),r={...s};let n=new h;for(const t of e){const[s,e,i]=t.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(n instanceof p&&(n.outdated=!0),n=this.parseLine(i,r),void 0!==e){if(void 0!==r[e])throw new Error("Attempt to redefine a known term: "+e);n=new p(e,n),r[e]=n}}for(const t in r)!s[t]&&r[t]instanceof c.classes.FreeVar&&(s[t]=r[t]);return n}parseLine(t,s={}){const e=[...t.matchAll(/([()A-Z]|[a-z_][a-z_0-9]*|\b[0-9]+\b|->)|($)|(?:^|\s+)/gys)],r=e.pop();if(""!==r[2])throw new Error("Unknown tokens in string starting with "+t.substring(r.index));const i=e.map((t=>t[1])).filter((t=>void 0!==t)),a=new h,p=[a];for(const e of i)if("("===e)p.push(a);else if(")"===e){if(p.length<2)throw new Error("unbalanced input: "+t);const s=p.pop().postParse(),e=p.pop();p.push(e.apply(s))}else if("->"===e){if(!this.hasLambdas)throw new Error("Lambdas not supported, allow them explicitly");p.push(new u(p.pop(),s))}else if(e.match(/^[0-9]+$/)){if(!this.hasNumbers)throw new Error("Church numbers not supported, allow them explicitly");const t=p.pop();p.push(t.apply(new o(e)))}else{const t=p.pop(),r=this.known[e]??(s[e]=s[e]??new n(e));p.push(t.apply(r))}if(1!==p.length)throw new Error("unbalanced input: "+t);return p.pop().postParse()}}c.free=(...t)=>t.map((t=>new n(t))),c.church=t=>new o(t),c.classes={Ast:s,Native:a,Alias:p,FreeVar:n,Lambda:i};for(const t in l)c[t]=l[t];t.exports={SKI:c}}},s={};!function e(r){var n=s[r];if(void 0!==n)return n.exports;var i=s[r]={exports:{}};return t[r](i,i.exports,e),i.exports}(10)})();