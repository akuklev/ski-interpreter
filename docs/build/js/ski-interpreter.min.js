(()=>{var t={10:(t,s,e)=>{const n=e(592),r=e(76);t.exports={...n,...r},"undefined"!=typeof window&&(window.SKI=n.SKI,window.SKI.Quest=r.Quest)},76:(t,s,e)=>{const{SKI:n}=e(592),{Alias:r,Lambda:i}=n.classes;class a{constructor(t,s={},e={},r=new n){if(2!==t.length)throw new Error("Case accepts exactly 2 strings");const[i,a]=t;this.max=s.max??1e3,this.note=s.note,e={...e};const o=t=>r.parse(t,e).run({max:this.max,throw:!0}).result;this.e1=o(i),this.e2=o(a)}check(t){const s=this.e1 instanceof i?this.e1.reduce([t]):this.e1.apply(t),e=s.run({max:this.max}),n=this.e2.expand().run({max:this.max},t);return{pass:e.final&&n.final&&e.result.equals(n.result),count:e.steps+n.steps,start:s,found:e.result,expected:n.result,note:this.note,args:[]}}}t.exports={Quest:class{constructor(t={}){const{title:s,descr:e,allow:r,numbers:i,vars:a,cases:o,lambdas:l,subst:h,engine:u,engineFull:p,...c}=t;if(this.engine=u??new n,this.engineFull=p??new n,this.restrict={allow:r,numbers:i??!1,lambdas:l??!1},this.vars={},this.subst=h??"f",a)for(const t of a){const s=this.engineFull.parse(t,this.vars);s instanceof n.classes.Alias&&(this.vars[s.name]=s.impl)}this.cases=[],this.title=s,this.descr=Array.isArray(e)?e.join(" "):e,this.meta=c;for(const t of o??[])this.add(...t)}add(t,...s){return"string"==typeof t&&(s.unshift(t),t={}),this.cases.push(new a(s,t,this.vars,this.engineFull)),this}check(t){try{let s="string"==typeof t?this.engine.parse(t,this.vars,this.restrict):t;this.subst&&(s=new r(this.subst,s));const e=this.cases.map((t=>t.check(s))),n=e.reduce(((t,s)=>t&&s.pass),!0);return{expr:s,pass:n,details:e}}catch(t){return{pass:!1,details:[],exception:t}}}show(){return[...this.cases]}}}},592:t=>{class s{constructor(){if(new.target===s)throw new Error("Attempt to instantiate abstract class Expr")}postParse(){return this}apply(...t){return t.length>0?new e(this,...t):this}expand(){return this}reduce(t){return null}subst(t){return null}step(){return null}run(t={},...e){t instanceof s&&(e.unshift(t),t={});let n=e?this.apply(...e):this,r=t.count??0;const i=(t.max??1e3)+r;let a=!1;for(;r<i;r++){const t=n.step();if(!t){a=!0;break}n=t}if(t.throw&&!a)throw new Error("Failed to compute expression in "+i+" steps");return{final:a,steps:r,result:n}}*walk(t={}){const s=t.max??1/0;let e=0,n=this,r=!1;for(;e<s;){const t=n.step();if(null===t&&(r=!0),yield{expr:n,steps:e,final:r},r)break;n=t,e++}}equals(t){return this===t}toString(){throw new Error("No toString() method defined in class "+this.constructor.name)}}class e extends s{constructor(t,...s){super(),this.fun=t,this.args=s,this.final=!1}apply(...t){return 0===t.length?this:this.fun.apply(...this.args,...t)}expand(){return this.fun.expand().apply(...this.args.map((t=>t.expand())))}subst(t){const s=this.fun.subst(t);let e=null===s?0:1;const n=[];for(const s of this.args){const r=s.subst(t);null===r?n.push(s):(n.push(r),e++)}return e?(s??this.fun).apply(...n):null}step(){if(this.final)return null;if(this.fun.fast){const t=this.fun.reduce(this.args);if(t)return t}const t=this.fun.step();let s=t?1:0;const e=[];for(const t of this.args){const n=t.step();e.push(n??t),n&&s++}if(s)return(t??this.fun).apply(...e);return this.fun.reduce(this.args)||(this.final=!0,null)}equals(t){if(!(t instanceof e))return!1;if(t.args.length!==this.args.length)return!1;if(!this.fun.equals(t.fun))return!1;for(let s=0;s<this.args.length;s++)if(!this.args[s].equals(t.args[s]))return!1;return!0}toString(){return(this.fun instanceof i?"("+this.fun+")":this.fun+"")+this.args.map((t=>"("+t+")")).join("")}}class n extends s{constructor(t){if(super(),"string"!=typeof t||0===t.length)throw new Error("Attempt to create a named term with improper name");this.name=t}toString(){return this.name}}class r extends n{subst(t){for(const s of t)if(this===s[0])return s[1];return null}}class i extends s{constructor(t,s){if(super(),0===t.length)throw new Error("empty argument list in lambda");const e=new Set;for(const s of t){if(e.has(s.name))throw new Error("Duplicate free var name "+s+" in lambda expression");e.add(s.name)}const n=t.map((t=>[t,new r(t.name)]));this.impl=s.subst(n)??s,this.args=n.map((t=>t[1]))}reduce(t){if(t.length<this.args.length)return null;const s=this.args.map(((s,e)=>[s,t[e]]));return(this.impl.subst(s)??this.impl).apply(...t.slice(this.args.length))}subst(t){const s=this.impl.subst(t);return s?new i(this.args,s):null}equals(t){if(!(t instanceof i))return!1;if(this.args.length!==t.args.length)return!1;const s=this.args.map(((t,s)=>new r("t"+s)));return t.reduce([...s]).equals(this.reduce([...s]))}toString(){return this.args.join("->")+"->"+this.impl}}class a extends n{constructor(t,s,e,n={}){super(t),this.arity=s,this.impl=e,n.fast&&(this.fast=!0),void 0!==n.note&&(this.note=n.note)}reduce(t){return t.length<this.arity?null:this.impl(...t.slice(0,this.arity)).apply(...t.slice(this.arity))}}class o extends a{constructor(t){const s=Number.parseInt(t);if(!(s>=0))throw new Error("Church number must be a nonnegative integer");super(""+s,2,(function(t,e){let n=e;for(let e=s;e-- >0;)n=t.apply(n);return n})),this.n=s}equals(t){return t instanceof o&&this.n===t.n}}class l extends n{constructor(t,s){super(t),this.impl=s}expand(){return this.impl.expand()}subst(t){return this.impl.subst(t)}step(){return this.impl}equals(t){return t.equals(this.impl)}toString(){return this.outdated?this.impl.toString():super.toString()}}class h extends s{apply(...t){return t.length?t.shift().apply(...t):this}postParse(){throw new Error("Attempt to use empty expression () as a term")}}class u extends h{constructor(t,s={}){if(super(),this.impl=new h,t instanceof r)this.terms=[t];else{if(!(t instanceof u))throw new Error("Expected FreeVar or PartialLambda");if(!(t.impl instanceof r))throw new Error("Expected FreeVar->...->FreeVar->Expr");this.terms=[...t.terms,t.impl]}}apply(t,...s){if(null===t||0!==s.length)throw new Error("bad syntax in partial lambda expr");return this.impl=this.impl.apply(t),this}postParse(){return new i(this.terms,this.impl)}}class p{constructor(...t){const s="$|(\\s+)|"+t.map((t=>"(?:"+t+")")).sort(((t,s)=>s.length-t.length)).join("|");this.rex=new RegExp(s,"gys")}split(t){this.rex.lastIndex=0;const s=[...t.matchAll(this.rex)],e=s.pop()?.index??0;if(e!==t.length)throw new Error("Unknown tokens at pos "+e+"/"+t.length+" starting with "+t.substring(e));return s.filter((t=>void 0===t[1])).map((t=>t[0]))}}const c={I:new a("I",1,(t=>t),{fast:!0,note:"x -> x"}),K:new a("K",2,((t,s)=>t),{fast:!0,note:"x -> y -> x"}),S:new a("S",3,((t,s,e)=>t.apply(e,s.apply(e))),{note:"x -> y -> z -> x z (y z)"}),B:new a("B",3,((t,s,e)=>t.apply(s.apply(e))),{note:"x -> y -> z -> x (y z)"}),C:new a("C",3,((t,s,e)=>t.apply(e).apply(s)),{note:"x -> y -> z -> x z y"}),W:new a("W",2,((t,s)=>t.apply(s).apply(s)),{note:"x -> y -> x y y"})},f=new p("[()]","[A-Z]","[a-z_][a-z_0-9]*","\\b[0-9]+\\b","->");class w{constructor(t={}){this.known={},this.hasNumbers=t.numbers??!0,this.hasLambdas=t.lambdas??!0,this.known={...c},this.allow=new Set(Object.keys(this.known)),t.allow&&this.restrict(t.allow)}add(t,e,n){if("string"==typeof e)e=new l(t,this.parseLine(e));else{if(!(e instanceof s))throw new Error("add: impl must be an Expr or a string");e=new l(t,e)}return void 0!==n&&(e.note=n),this.known[t]=e,this.allow.add(t),this}maybeAdd(t,s){return this.known[t]?this.allow.add(t):this.add(t,s),this}restrict(t){return this.allow=d(this.allow,t),this}remove(t){return this.known[t].outdated=!0,delete this.known[t],this.allow.delete(t),this}getTerms(){const t={};for(const s of Object.keys(this.known))this.allow.has(s)&&(t[s]=this.known[s]);return t}parse(t,s={},e={}){const n=t.replace(/\/\/[^\n]*\n/gs,"").split(/\s*;[\s;]*/).filter((t=>t.match(/\S/))),r={...s};let i=new h;for(const t of n){const[s,n,a]=t.match(/^(?:\s*([A-Z]|[a-z][a-z_0-9]*)\s*=\s*)?(.*)$/s);if(i instanceof l&&(i.outdated=!0),i=this.parseLine(a,r,e),void 0!==n){if(void 0!==r[n])throw new Error("Attempt to redefine a known term: "+n);i=new l(n,i),r[n]=i}}for(const t in r)!s[t]&&r[t]instanceof w.classes.FreeVar&&(s[t]=r[t]);return i}parseLine(t,s={},e={}){const n={numbers:e.numbers??this.hasNumbers,lambdas:e.lambdas??this.hasLambdas,allow:d(this.allow,e.allow)},i=f.split(t),a=new h,l=[a];for(const e of i)if("("===e)l.push(a);else if(")"===e){if(l.length<2)throw new Error("unbalanced input: "+t);const s=l.pop().postParse(),e=l.pop();l.push(e.apply(s))}else if("->"===e){if(!n.lambdas)throw new Error("Lambdas not supported, allow them explicitly");l.push(new u(l.pop(),s))}else if(e.match(/^[0-9]+$/)){if(!n.numbers)throw new Error("Church numbers not supported, allow them explicitly");const t=l.pop();l.push(t.apply(new o(e)))}else{const t=l.pop();if(this.known[e]&&!n.allow.has(e))throw new Error("Term "+e+" is not in the restricted set "+[...n.allow].sort().join(" "));const i=this.known[e]??(s[e]=s[e]??new r(e));l.push(t.apply(i))}if(1!==l.length)throw new Error("unbalanced input: "+t);return l.pop().postParse()}}const m=new p("[-=+]","[A-Z]","\b[a-z_][a-z_0-9]*\b");function d(t,s){if(!s)return t;let e=new Set([...t]),n=0;const r=[t=>{e=new Set([t]),n=1},t=>{e.add(t)},t=>{e.delete(t)}];for(const t of m.split(s))"="===t?n=0:"+"===t?n=1:"-"===t?n=2:r[n](t);return e}w.free=(...t)=>t.map((t=>new r(t))),w.church=t=>new o(t),w.classes={Expr:s,Native:a,Alias:l,FreeVar:r,Lambda:i};for(const t in c)w[t]=c[t];t.exports={SKI:w}}},s={};!function e(n){var r=s[n];if(void 0!==r)return r.exports;var i=s[n]={exports:{}};return t[n](i,i.exports,e),i.exports}(10)})();