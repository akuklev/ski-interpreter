[
  {
    "title": "Warm up",
    "descr": [
      "Provide a term that returns <code>K</code> for <code>I</code> and <code>I</code> for <code>K</code>."
    ],
    "subst": "&phi;",
    "cases": [
      [ "phi->phi I", "phi->K" ],
      [ "phi->phi K", "phi->I" ]
    ]
  },
  {
    "title": "not",
    "descr": [
      "Implement <code>not x</code>, that is,",
      "return <code>K</code> for <code>KI</code> and <code>KI</code> for <code>K</code>"
    ],
    "subst": "&phi;",
    "cases": [
      [ "phi->phi (KI) x y", "phi->x" ],
      [ "phi->phi K x y", "phi->y" ]
    ]
  },
  {
    "title": "and",
    "descr": [
      "make a term that takes 2 arguments and returns true (<code>K</code>)",
      " if and only if both are true"
    ],
    "subst": "&phi;",
    "cases": [
      [ "phi->phi K K", "phi->K" ],
      [ "phi->phi (KI) K", "phi->KI" ],
      [ "phi->phi K (KI)", "phi->KI" ],
      [ "phi->phi (KI) (KI)", "phi->KI" ]
    ]
  },
  {
    "title": "or",
    "descr": [
      "the title says it"
    ],
    "subst": "&phi;",
    "cases": [
      [ "phi->phi K K", "phi->K" ],
      [ "phi->phi (KI) K", "phi->K" ],
      [ "phi->phi K (KI)", "phi->K" ],
      [ "phi->phi (KI) (KI)", "phi->KI" ]
    ]
  },
  {
    "title": "nand",
    "descr": [
      "NAND (not and) is true unless both ot its inputs are true."
    ],
    "subst": "&phi;",
    "cases": [
      [ "phi->phi K K", "phi->KI" ],
      [ "phi->phi (KI) K", "phi->K" ],
      [ "phi->phi K (KI)", "phi->K" ],
      [ "phi->phi (KI) (KI)", "phi->K" ]
    ]
  },
  {
    "title": "Postfix if statement",
    "descr": [
      "Often the then/else branches are known before the condition that picks one of them.",
      "Provide a function that takes then/else terms and feeds them to its third argument."
    ],
    "subst": "&phi;",
    "cases": [
      [ "phi->phi x y K", "phi->x" ],
      [ "phi->phi x y (KI)", "phi->y" ],
      [ "phi->phi x y (SK)", "phi->y" ]
    ]
  }
]
